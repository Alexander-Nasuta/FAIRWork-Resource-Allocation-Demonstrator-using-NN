# coding: utf-8

"""
    Api Documentation

    Api Documentation  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class AdminControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def activate_proj_using_put(self, proj_id, token, **kwargs):  # noqa: E501
        """Set project active  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activate_proj_using_put(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.activate_proj_using_put_with_http_info(proj_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.activate_proj_using_put_with_http_info(proj_id, token, **kwargs)  # noqa: E501
            return data

    def activate_proj_using_put_with_http_info(self, proj_id, token, **kwargs):  # noqa: E501
        """Set project active  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.activate_proj_using_put_with_http_info(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_proj_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj_id' is set
        if ('proj_id' not in params or
                params['proj_id'] is None):
            raise ValueError("Missing the required parameter `proj_id` when calling `activate_proj_using_put`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `activate_proj_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proj_id' in params:
            path_params['proj_id'] = params['proj_id']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/proj/active/{proj_id}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project_using_post(self, descr, name, token, **kwargs):  # noqa: E501
        """Create new project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_using_post(descr, name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str name: Node/Project name (required)
        :param str token: Server connection token (required)
        :param str file:
        :param str folder: Project folder for the new project placement
        :param bool is_bkd_tmpl: Create new project as a breakdown template(true) or not(false)
        :param bool is_tmpl: Create new project as a project template(true) or not(false)
        :param str node_type: Node type
        :param str src: Type of the data file
        :param str tmpl: Project template model name for the new project initialisation
        :return: ProjectInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_project_using_post_with_http_info(descr, name, token, **kwargs)  # noqa: E501
        else:
            (data) = self.create_project_using_post_with_http_info(descr, name, token, **kwargs)  # noqa: E501
            return data

    def create_project_using_post_with_http_info(self, descr, name, token, **kwargs):  # noqa: E501
        """Create new project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_using_post_with_http_info(descr, name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str name: Node/Project name (required)
        :param str token: Server connection token (required)
        :param str file:
        :param str folder: Project folder for the new project placement
        :param bool is_bkd_tmpl: Create new project as a breakdown template(true) or not(false)
        :param bool is_tmpl: Create new project as a project template(true) or not(false)
        :param str node_type: Node type
        :param str src: Type of the data file
        :param str tmpl: Project template model name for the new project initialisation
        :return: ProjectInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['descr', 'name', 'token', 'file', 'folder', 'is_bkd_tmpl', 'is_tmpl', 'node_type', 'src', 'tmpl']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'descr' is set
        if ('descr' not in params or
                params['descr'] is None):
            raise ValueError("Missing the required parameter `descr` when calling `create_project_using_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_project_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `create_project_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'folder' in params:
            query_params.append(('folder', params['folder']))  # noqa: E501
        if 'is_bkd_tmpl' in params:
            query_params.append(('is_bkd_tmpl', params['is_bkd_tmpl']))  # noqa: E501
        if 'is_tmpl' in params:
            query_params.append(('is_tmpl', params['is_tmpl']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'node_type' in params:
            query_params.append(('nodeType', params['node_type']))  # noqa: E501
        if 'src' in params:
            query_params.append(('src', params['src']))  # noqa: E501
        if 'tmpl' in params:
            query_params.append(('tmpl', params['tmpl']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_proj_using_delete(self, proj_id, token, **kwargs):  # noqa: E501
        """Delete project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_proj_using_delete(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_proj_using_delete_with_http_info(proj_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_proj_using_delete_with_http_info(proj_id, token, **kwargs)  # noqa: E501
            return data

    def delete_proj_using_delete_with_http_info(self, proj_id, token, **kwargs):  # noqa: E501
        """Delete project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_proj_using_delete_with_http_info(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_proj_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj_id' is set
        if ('proj_id' not in params or
                params['proj_id'] is None):
            raise ValueError("Missing the required parameter `proj_id` when calling `delete_proj_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_proj_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proj_id' in params:
            path_params['proj_id'] = params['proj_id']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/proj/{proj_id}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_from_project_using_delete(self, proj, token, user, **kwargs):  # noqa: E501
        """Delete user from the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_from_project_using_delete(proj, token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj: Project GUID (required)
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_user_from_project_using_delete_with_http_info(proj, token, user, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_from_project_using_delete_with_http_info(proj, token, user, **kwargs)  # noqa: E501
            return data

    def delete_user_from_project_using_delete_with_http_info(self, proj, token, user, **kwargs):  # noqa: E501
        """Delete user from the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_from_project_using_delete_with_http_info(proj, token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj: Project GUID (required)
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj', 'token', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_from_project_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj' is set
        if ('proj' not in params or
                params['proj'] is None):
            raise ValueError("Missing the required parameter `proj` when calling `delete_user_from_project_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_user_from_project_using_delete`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `delete_user_from_project_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'proj' in params:
            query_params.append(('proj', params['proj']))  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/users/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_using_delete(self, token, user, **kwargs):  # noqa: E501
        """Delete user from the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_using_delete(token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param str user: Login of the user (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_user_using_delete_with_http_info(token, user, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_using_delete_with_http_info(token, user, **kwargs)  # noqa: E501
            return data

    def delete_user_using_delete_with_http_info(self, token, user, **kwargs):  # noqa: E501
        """Delete user from the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_using_delete_with_http_info(token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param str user: Login of the user (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_user_using_delete`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `delete_user_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/names/{user}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_proj_using_get(self, token, **kwargs):  # noqa: E501
        """Return the list of all projects in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_proj_using_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[SystemProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_proj_using_get_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_proj_using_get_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_all_proj_using_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Return the list of all projects in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_proj_using_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[SystemProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_proj_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_all_proj_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/proj/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SystemProjectInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_child_types_tree_using_get(self, model, repository, token, type, **kwargs):  # noqa: E501
        """Return tree of the direct subtypes of the specified supertype and so on  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_child_types_tree_using_get(model, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Supertype URN (required)
        :return: list[TypeNode]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_child_types_tree_using_get_with_http_info(model, repository, token, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_child_types_tree_using_get_with_http_info(model, repository, token, type, **kwargs)  # noqa: E501
            return data

    def get_child_types_tree_using_get_with_http_info(self, model, repository, token, type, **kwargs):  # noqa: E501
        """Return tree of the direct subtypes of the specified supertype and so on  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_child_types_tree_using_get_with_http_info(model, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Supertype URN (required)
        :return: list[TypeNode]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_child_types_tree_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_child_types_tree_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_child_types_tree_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_child_types_tree_using_get`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_child_types_tree_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/class_tree/{repository}/{model}/{type}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TypeNode]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_class_elems_using_get(self, model, repository, token, type, **kwargs):  # noqa: E501
        """Return list of the direct subtypes of the specified supertype  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_class_elems_using_get(model, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: type (required)
        :return: list[RDLClass]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_class_elems_using_get_with_http_info(model, repository, token, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_class_elems_using_get_with_http_info(model, repository, token, type, **kwargs)  # noqa: E501
            return data

    def get_class_elems_using_get_with_http_info(self, model, repository, token, type, **kwargs):  # noqa: E501
        """Return list of the direct subtypes of the specified supertype  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_class_elems_using_get_with_http_info(model, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: type (required)
        :return: list[RDLClass]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_class_elems_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_class_elems_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_class_elems_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_class_elems_using_get`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_class_elems_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/class/{repository}/{model}/{type}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RDLClass]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_phase_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Return project phase value  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_phase_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StringResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_current_phase_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_current_phase_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def get_current_phase_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Return project phase value  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_phase_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StringResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_phase_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_current_phase_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_current_phase_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_current_phase_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/phase/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_error_info_using_get(self, error, token, **kwargs):  # noqa: E501
        """Return error description  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_error_info_using_get(error, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int error: Error code (required)
        :param str token: Server connection token (required)
        :return: StringResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_error_info_using_get_with_http_info(error, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_error_info_using_get_with_http_info(error, token, **kwargs)  # noqa: E501
            return data

    def get_error_info_using_get_with_http_info(self, error, token, **kwargs):  # noqa: E501
        """Return error description  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_error_info_using_get_with_http_info(error, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int error: Error code (required)
        :param str token: Server connection token (required)
        :return: StringResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['error', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_error_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'error' is set
        if ('error' not in params or
                params['error'] is None):
            raise ValueError("Missing the required parameter `error` when calling `get_error_info_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_error_info_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'error' in params:
            path_params['error'] = params['error']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/error/{error}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_inst_info_using_get(self, inst_id, token, **kwargs):  # noqa: E501
        """Return project info by the instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inst_info_using_get(inst_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inst_id: Instance ID of the breakdown element (required)
        :param str token: Server connection token (required)
        :return: ProjectInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_inst_info_using_get_with_http_info(inst_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_inst_info_using_get_with_http_info(inst_id, token, **kwargs)  # noqa: E501
            return data

    def get_inst_info_using_get_with_http_info(self, inst_id, token, **kwargs):  # noqa: E501
        """Return project info by the instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_inst_info_using_get_with_http_info(inst_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inst_id: Instance ID of the breakdown element (required)
        :param str token: Server connection token (required)
        :return: ProjectInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inst_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inst_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inst_id' is set
        if ('inst_id' not in params or
                params['inst_id'] is None):
            raise ValueError("Missing the required parameter `inst_id` when calling `get_inst_info_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_inst_info_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inst_id' in params:
            path_params['inst_id'] = params['inst_id']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/inst/{inst_id}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_proj_info_using_get(self, proj_id, token, **kwargs):  # noqa: E501
        """Return project info by GUID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_proj_info_using_get(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: SystemProjectInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_proj_info_using_get_with_http_info(proj_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_proj_info_using_get_with_http_info(proj_id, token, **kwargs)  # noqa: E501
            return data

    def get_proj_info_using_get_with_http_info(self, proj_id, token, **kwargs):  # noqa: E501
        """Return project info by GUID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_proj_info_using_get_with_http_info(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: SystemProjectInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_proj_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj_id' is set
        if ('proj_id' not in params or
                params['proj_id'] is None):
            raise ValueError("Missing the required parameter `proj_id` when calling `get_proj_info_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_proj_info_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proj_id' in params:
            path_params['proj_id'] = params['proj_id']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/proj/{proj_id}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemProjectInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_users_using_get(self, proj, token, **kwargs):  # noqa: E501
        """Return list of users on the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_users_using_get(proj, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj: Project GUID (required)
        :param str token: Server connection token (required)
        :return: list[UsersProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_users_using_get_with_http_info(proj, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_users_using_get_with_http_info(proj, token, **kwargs)  # noqa: E501
            return data

    def get_project_users_using_get_with_http_info(self, proj, token, **kwargs):  # noqa: E501
        """Return list of users on the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_users_using_get_with_http_info(proj, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj: Project GUID (required)
        :param str token: Server connection token (required)
        :return: list[UsersProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_users_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj' is set
        if ('proj' not in params or
                params['proj'] is None):
            raise ValueError("Missing the required parameter `proj` when calling `get_project_users_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_project_users_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'proj' in params:
            query_params.append(('proj', params['proj']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/users/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UsersProjectInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prop_elems_using_get(self, model, repository, token, type, **kwargs):  # noqa: E501
        """Return list of the properties with the usage check  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prop_elems_using_get(model, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Breakdown element type (required)
        :param bool is_aggr: Is aggrigate structure
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_prop_elems_using_get_with_http_info(model, repository, token, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_prop_elems_using_get_with_http_info(model, repository, token, type, **kwargs)  # noqa: E501
            return data

    def get_prop_elems_using_get_with_http_info(self, model, repository, token, type, **kwargs):  # noqa: E501
        """Return list of the properties with the usage check  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prop_elems_using_get_with_http_info(model, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Breakdown element type (required)
        :param bool is_aggr: Is aggrigate structure
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'type', 'is_aggr']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prop_elems_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_prop_elems_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_prop_elems_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_prop_elems_using_get`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_prop_elems_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []
        if 'is_aggr' in params:
            query_params.append(('is_aggr', params['is_aggr']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/prop/{repository}/{model}/{type}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_prop_info_using_get(self, model, prop, repository, token, **kwargs):  # noqa: E501
        """Return info for the specified property name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prop_info_using_get(model, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str prop: Ptoperty name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_prop_info_using_get_with_http_info(model, prop, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_prop_info_using_get_with_http_info(model, prop, repository, token, **kwargs)  # noqa: E501
            return data

    def get_prop_info_using_get_with_http_info(self, model, prop, repository, token, **kwargs):  # noqa: E501
        """Return info for the specified property name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_prop_info_using_get_with_http_info(model, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str prop: Ptoperty name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'prop', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_prop_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_prop_info_using_get`")  # noqa: E501
        # verify the required parameter 'prop' is set
        if ('prop' not in params or
                params['prop'] is None):
            raise ValueError("Missing the required parameter `prop` when calling `get_prop_info_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_prop_info_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_prop_info_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'prop' in params:
            path_params['prop'] = params['prop']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/prop_info/{repository}/{model}/{prop}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_q_rcode_file_using_get(self, token, user, **kwargs):  # noqa: E501
        """Get QR code image for 2FA code for the current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_q_rcode_file_using_get(token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: ByteArrayResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_q_rcode_file_using_get_with_http_info(token, user, **kwargs)  # noqa: E501
        else:
            (data) = self.get_q_rcode_file_using_get_with_http_info(token, user, **kwargs)  # noqa: E501
            return data

    def get_q_rcode_file_using_get_with_http_info(self, token, user, **kwargs):  # noqa: E501
        """Get QR code image for 2FA code for the current user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_q_rcode_file_using_get_with_http_info(token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: ByteArrayResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_q_rcode_file_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_q_rcode_file_using_get`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `get_q_rcode_file_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/code2fa/{user}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ByteArrayResource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tmpl_projects_using_get(self, token, **kwargs):  # noqa: E501
        """Return list of the project and breakdown templates in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tmpl_projects_using_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[UsersProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tmpl_projects_using_get_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tmpl_projects_using_get_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_tmpl_projects_using_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Return list of the project and breakdown templates in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tmpl_projects_using_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[UsersProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tmpl_projects_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_tmpl_projects_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/tmpl/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UsersProjectInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_info_using_get(self, token, **kwargs):  # noqa: E501
        """Return all info about current truePLM user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info_using_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[LoginInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_info_using_get_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_info_using_get_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_user_info_using_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Return all info about current truePLM user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info_using_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[LoginInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_user_info_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/all_user_info/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LoginInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_projects_using_get(self, token, **kwargs):  # noqa: E501
        """Return all projects of the current truePLM user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_projects_using_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[UsersProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_projects_using_get_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_projects_using_get_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_user_projects_using_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Return all projects of the current truePLM user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_projects_using_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[UsersProjectInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_projects_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_user_projects_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/all_user_proj/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UsersProjectInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users_info_using_get(self, token, **kwargs):  # noqa: E501
        """Return all info about truePLM users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_info_using_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[LoginInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_users_info_using_get_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_users_info_using_get_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_users_info_using_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Return all info about truePLM users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_info_using_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[LoginInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_users_info_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/all_users_info/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LoginInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users_using_get(self, token, **kwargs):  # noqa: E501
        """Return list of user logins in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_using_get(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[StringValue]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_users_using_get_with_http_info(token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_users_using_get_with_http_info(token, **kwargs)  # noqa: E501
            return data

    def get_users_using_get_with_http_info(self, token, **kwargs):  # noqa: E501
        """Return list of user logins in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_using_get_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :return: list[StringValue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_users_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/names/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StringValue]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def import_data_to_project_using_post(self, file, proj, rep, token, **kwargs):  # noqa: E501
        """Import data to the existing project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_to_project_using_post(file, proj, rep, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str proj: Model name (required)
        :param str rep: Repository name (required)
        :param str token: Server connection token (required)
        :param str src: Type of the data file
        :param str user: User login
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.import_data_to_project_using_post_with_http_info(file, proj, rep, token, **kwargs)  # noqa: E501
        else:
            (data) = self.import_data_to_project_using_post_with_http_info(file, proj, rep, token, **kwargs)  # noqa: E501
            return data

    def import_data_to_project_using_post_with_http_info(self, file, proj, rep, token, **kwargs):  # noqa: E501
        """Import data to the existing project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.import_data_to_project_using_post_with_http_info(file, proj, rep, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str proj: Model name (required)
        :param str rep: Repository name (required)
        :param str token: Server connection token (required)
        :param str src: Type of the data file
        :param str user: User login
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'proj', 'rep', 'token', 'src', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method import_data_to_project_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `import_data_to_project_using_post`")  # noqa: E501
        # verify the required parameter 'proj' is set
        if ('proj' not in params or
                params['proj'] is None):
            raise ValueError("Missing the required parameter `proj` when calling `import_data_to_project_using_post`")  # noqa: E501
        # verify the required parameter 'rep' is set
        if ('rep' not in params or
                params['rep'] is None):
            raise ValueError("Missing the required parameter `rep` when calling `import_data_to_project_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `import_data_to_project_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proj' in params:
            path_params['proj'] = params['proj']  # noqa: E501
        if 'rep' in params:
            path_params['rep'] = params['rep']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'src' in params:
            query_params.append(('src', params['src']))  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/import/{rep}/{proj}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inactivate_proj_using_put(self, proj_id, token, **kwargs):  # noqa: E501
        """Set project inactive  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inactivate_proj_using_put(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.inactivate_proj_using_put_with_http_info(proj_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.inactivate_proj_using_put_with_http_info(proj_id, token, **kwargs)  # noqa: E501
            return data

    def inactivate_proj_using_put_with_http_info(self, proj_id, token, **kwargs):  # noqa: E501
        """Set project inactive  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inactivate_proj_using_put_with_http_info(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inactivate_proj_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj_id' is set
        if ('proj_id' not in params or
                params['proj_id'] is None):
            raise ValueError("Missing the required parameter `proj_id` when calling `inactivate_proj_using_put`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `inactivate_proj_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proj_id' in params:
            path_params['proj_id'] = params['proj_id']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/proj/inactive/{proj_id}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_project_info_using_post(self, proj_id, token, **kwargs):  # noqa: E501
        """Update project information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_info_using_post(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :param bool auto_ver: Use auto versioning in the project
        :param float budget: Budget value of the project
        :param str customer: Castomer of the project
        :param str deadline: Deadline of the project
        :param str descr: Description of the project
        :param str end_date: End date of the project
        :param bool mass_budget: Use mass budget property in the project
        :param str partners: Partners of the project
        :param str phase: Phase of the project
        :param str po_number: PO number of the project
        :param str start_date: Start date of the project
        :param str status: Status of the project
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_project_info_using_post_with_http_info(proj_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.set_project_info_using_post_with_http_info(proj_id, token, **kwargs)  # noqa: E501
            return data

    def set_project_info_using_post_with_http_info(self, proj_id, token, **kwargs):  # noqa: E501
        """Update project information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_project_info_using_post_with_http_info(proj_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj_id: Project GUID (required)
        :param str token: Server connection token (required)
        :param bool auto_ver: Use auto versioning in the project
        :param float budget: Budget value of the project
        :param str customer: Castomer of the project
        :param str deadline: Deadline of the project
        :param str descr: Description of the project
        :param str end_date: End date of the project
        :param bool mass_budget: Use mass budget property in the project
        :param str partners: Partners of the project
        :param str phase: Phase of the project
        :param str po_number: PO number of the project
        :param str start_date: Start date of the project
        :param str status: Status of the project
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj_id', 'token', 'auto_ver', 'budget', 'customer', 'deadline', 'descr', 'end_date', 'mass_budget', 'partners', 'phase', 'po_number', 'start_date', 'status']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_project_info_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj_id' is set
        if ('proj_id' not in params or
                params['proj_id'] is None):
            raise ValueError("Missing the required parameter `proj_id` when calling `set_project_info_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `set_project_info_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'proj_id' in params:
            path_params['proj_id'] = params['proj_id']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'auto_ver' in params:
            query_params.append(('auto_ver', params['auto_ver']))  # noqa: E501
        if 'budget' in params:
            query_params.append(('budget', params['budget']))  # noqa: E501
        if 'customer' in params:
            query_params.append(('customer', params['customer']))  # noqa: E501
        if 'deadline' in params:
            query_params.append(('deadline', params['deadline']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'mass_budget' in params:
            query_params.append(('mass_budget', params['mass_budget']))  # noqa: E501
        if 'partners' in params:
            query_params.append(('partners', params['partners']))  # noqa: E501
        if 'phase' in params:
            query_params.append(('phase', params['phase']))  # noqa: E501
        if 'po_number' in params:
            query_params.append(('po_number', params['po_number']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/proj/{proj_id}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_user_on_project_using_post(self, proj, role, token, user, **kwargs):  # noqa: E501
        """Add user with roles to the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_user_on_project_using_post(proj, role, token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj: Project GUID (required)
        :param list[str] role: List of user roles (required)
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_user_on_project_using_post_with_http_info(proj, role, token, user, **kwargs)  # noqa: E501
        else:
            (data) = self.set_user_on_project_using_post_with_http_info(proj, role, token, user, **kwargs)  # noqa: E501
            return data

    def set_user_on_project_using_post_with_http_info(self, proj, role, token, user, **kwargs):  # noqa: E501
        """Add user with roles to the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_user_on_project_using_post_with_http_info(proj, role, token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int proj: Project GUID (required)
        :param list[str] role: List of user roles (required)
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['proj', 'role', 'token', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_user_on_project_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'proj' is set
        if ('proj' not in params or
                params['proj'] is None):
            raise ValueError("Missing the required parameter `proj` when calling `set_user_on_project_using_post`")  # noqa: E501
        # verify the required parameter 'role' is set
        if ('role' not in params or
                params['role'] is None):
            raise ValueError("Missing the required parameter `role` when calling `set_user_on_project_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `set_user_on_project_using_post`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `set_user_on_project_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'proj' in params:
            query_params.append(('proj', params['proj']))  # noqa: E501
        if 'role' in params:
            query_params.append(('role', params['role']))  # noqa: E501
            collection_formats['role'] = 'multi'  # noqa: E501
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/users/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_current_pass_using_post(self, info, token, **kwargs):  # noqa: E501
        """Update user password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_current_pass_using_post(info, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str info: Password information (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_current_pass_using_post_with_http_info(info, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_current_pass_using_post_with_http_info(info, token, **kwargs)  # noqa: E501
            return data

    def update_current_pass_using_post_with_http_info(self, info, token, **kwargs):  # noqa: E501
        """Update user password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_current_pass_using_post_with_http_info(info, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str info: Password information (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['info', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_current_pass_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'info' is set
        if ('info' not in params or
                params['info'] is None):
            raise ValueError("Missing the required parameter `info` when calling `update_current_pass_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_current_pass_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'info' in params:
            query_params.append(('info', params['info']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/names/user/pass/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_phase_using_post(self, model, repository, token, value, **kwargs):  # noqa: E501
        """Update project phase value  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_phase_using_post(model, repository, token, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str value: Phase value (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_phase_using_post_with_http_info(model, repository, token, value, **kwargs)  # noqa: E501
        else:
            (data) = self.update_phase_using_post_with_http_info(model, repository, token, value, **kwargs)  # noqa: E501
            return data

    def update_phase_using_post_with_http_info(self, model, repository, token, value, **kwargs):  # noqa: E501
        """Update project phase value  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_phase_using_post_with_http_info(model, repository, token, value, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str value: Phase value (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'value']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_phase_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `update_phase_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `update_phase_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_phase_using_post`")  # noqa: E501
        # verify the required parameter 'value' is set
        if ('value' not in params or
                params['value'] is None):
            raise ValueError("Missing the required parameter `value` when calling `update_phase_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/phase/{repository}/{model}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user2_f_aby_admin_using_post(self, token, use2fa, user, **kwargs):  # noqa: E501
        """Update user 2FA setting by admin  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user2_f_aby_admin_using_post(token, use2fa, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param bool use2fa: 2FA state (required)
        :param str user: User login (required)
        :param bool reset_code: Reset current code
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user2_f_aby_admin_using_post_with_http_info(token, use2fa, user, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user2_f_aby_admin_using_post_with_http_info(token, use2fa, user, **kwargs)  # noqa: E501
            return data

    def update_user2_f_aby_admin_using_post_with_http_info(self, token, use2fa, user, **kwargs):  # noqa: E501
        """Update user 2FA setting by admin  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user2_f_aby_admin_using_post_with_http_info(token, use2fa, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param bool use2fa: 2FA state (required)
        :param str user: User login (required)
        :param bool reset_code: Reset current code
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'use2fa', 'user', 'reset_code']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user2_f_aby_admin_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_user2_f_aby_admin_using_post`")  # noqa: E501
        # verify the required parameter 'use2fa' is set
        if ('use2fa' not in params or
                params['use2fa'] is None):
            raise ValueError("Missing the required parameter `use2fa` when calling `update_user2_f_aby_admin_using_post`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `update_user2_f_aby_admin_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []
        if 'reset_code' in params:
            query_params.append(('reset_code', params['reset_code']))  # noqa: E501
        if 'use2fa' in params:
            query_params.append(('use2fa', params['use2fa']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/user2fa/{user}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_pass_using_get(self, token, user, **kwargs):  # noqa: E501
        """Get user settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_pass_using_get(token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: LoginInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_pass_using_get_with_http_info(token, user, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_pass_using_get_with_http_info(token, user, **kwargs)  # noqa: E501
            return data

    def update_user_pass_using_get_with_http_info(self, token, user, **kwargs):  # noqa: E501
        """Get user settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_pass_using_get_with_http_info(token, user, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Server connection token (required)
        :param str user: User login (required)
        :return: LoginInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token', 'user']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_pass_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_user_pass_using_get`")  # noqa: E501
        # verify the required parameter 'user' is set
        if ('user' not in params or
                params['user'] is None):
            raise ValueError("Missing the required parameter `user` when calling `update_user_pass_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'user' in params:
            path_params['user'] = params['user']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/settings/{user}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoginInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_using_post(self, name, token, **kwargs):  # noqa: E501
        """Update user information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_using_post(name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: User's login (required)
        :param str token: Server connection token (required)
        :param str email: User's e-mail
        :param str organization: User's organisation
        :param str _pass: User's password
        :param str real_name: User's real name
        :param str sso_id: SSO ID
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_using_post_with_http_info(name, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_using_post_with_http_info(name, token, **kwargs)  # noqa: E501
            return data

    def update_user_using_post_with_http_info(self, name, token, **kwargs):  # noqa: E501
        """Update user information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_using_post_with_http_info(name, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: User's login (required)
        :param str token: Server connection token (required)
        :param str email: User's e-mail
        :param str organization: User's organisation
        :param str _pass: User's password
        :param str real_name: User's real name
        :param str sso_id: SSO ID
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'token', 'email', 'organization', '_pass', 'real_name', 'sso_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_user_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_user_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'organization' in params:
            query_params.append(('organization', params['organization']))  # noqa: E501
        if '_pass' in params:
            query_params.append(('pass', params['_pass']))  # noqa: E501
        if 'real_name' in params:
            query_params.append(('realName', params['real_name']))  # noqa: E501
        if 'sso_id' in params:
            query_params.append(('sso_id', params['sso_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/adm_user/names/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
