# coding: utf-8

"""
    Api Documentation

    Api Documentation  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class BreakdownControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_part_to_node_using_post(self, model, node, prod, repository, token, **kwargs):  # noqa: E501
        """Add product link to the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_part_to_node_using_post(model, node, prod, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param int prod: Instance ID of the representing_part or Product_view_definition of the product (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: RepresentingPartV
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_part_to_node_using_post_with_http_info(model, node, prod, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.add_part_to_node_using_post_with_http_info(model, node, prod, repository, token, **kwargs)  # noqa: E501
            return data

    def add_part_to_node_using_post_with_http_info(self, model, node, prod, repository, token, **kwargs):  # noqa: E501
        """Add product link to the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_part_to_node_using_post_with_http_info(model, node, prod, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param int prod: Instance ID of the representing_part or Product_view_definition of the product (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: RepresentingPartV
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'prod', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_part_to_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `add_part_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `add_part_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'prod' is set
        if ('prod' not in params or
                params['prod'] is None):
            raise ValueError("Missing the required parameter `prod` when calling `add_part_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `add_part_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `add_part_to_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'prod' in params:
            query_params.append(('prod', params['prod']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/unit/{repository}/{model}/{node}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepresentingPartV',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_relation_to_node_using_post(self, ch_node, model, node, r_type, repository, token, **kwargs):  # noqa: E501
        """Add relationship from parent breakdown element to child breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_relation_to_node_using_post(ch_node, model, node, r_type, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ch_node: Related breakdown element instance ID (required)
        :param str model: Model name (required)
        :param int node: Relating breakdown element instance ID (required)
        :param str r_type: Relation type (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str remark: Remark text
        :param str title1: Relating element title
        :param str title2: Related element title
        :return: BeReferenceInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_relation_to_node_using_post_with_http_info(ch_node, model, node, r_type, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.add_relation_to_node_using_post_with_http_info(ch_node, model, node, r_type, repository, token, **kwargs)  # noqa: E501
            return data

    def add_relation_to_node_using_post_with_http_info(self, ch_node, model, node, r_type, repository, token, **kwargs):  # noqa: E501
        """Add relationship from parent breakdown element to child breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_relation_to_node_using_post_with_http_info(ch_node, model, node, r_type, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ch_node: Related breakdown element instance ID (required)
        :param str model: Model name (required)
        :param int node: Relating breakdown element instance ID (required)
        :param str r_type: Relation type (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str remark: Remark text
        :param str title1: Relating element title
        :param str title2: Related element title
        :return: BeReferenceInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ch_node', 'model', 'node', 'r_type', 'repository', 'token', 'remark', 'title1', 'title2']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_relation_to_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ch_node' is set
        if ('ch_node' not in params or
                params['ch_node'] is None):
            raise ValueError("Missing the required parameter `ch_node` when calling `add_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `add_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `add_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'r_type' is set
        if ('r_type' not in params or
                params['r_type'] is None):
            raise ValueError("Missing the required parameter `r_type` when calling `add_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `add_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `add_relation_to_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'ch_node' in params:
            query_params.append(('chNode', params['ch_node']))  # noqa: E501
        if 'r_type' in params:
            query_params.append(('r_type', params['r_type']))  # noqa: E501
        if 'remark' in params:
            query_params.append(('remark', params['remark']))  # noqa: E501
        if 'title1' in params:
            query_params.append(('title1', params['title1']))  # noqa: E501
        if 'title2' in params:
            query_params.append(('title2', params['title2']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/rel/{repository}/{model}/{node}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BeReferenceInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def advanced_search_node_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Advanced search for the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.advanced_search_node_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str create_after: Search for the breakdown element created after the specified date
        :param str create_before: Search for the breakdown element created before the specified date
        :param str create_user: Search value for the breakdown element creator person
        :param str descr: Search pattern for the breakdown element description
        :param str edit_after: Search for the breakdown element edited after the specified date
        :param str edit_before: Search for the breakdown element edited before the specified date
        :param str edit_user: Search value for the breakdown element editor person
        :param int limit: Limit for the number of search result
        :param int node_id: Root element's instance ID of the branch to search within
        :param str node_ver: Version number of the element to search within
        :param str p_phase: Project phase to search within
        :param str pattern: Search pattern for the breakdown element name
        :param list[str] prop_name: List of the breakdown element property names to search for
        :param list[str] prop_val: List of the breakdown element property values to search for
        :param str type: Search pattern for the breakdown element type
        :return: list[BreakdownElementSearchResultInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.advanced_search_node_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.advanced_search_node_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def advanced_search_node_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Advanced search for the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.advanced_search_node_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str create_after: Search for the breakdown element created after the specified date
        :param str create_before: Search for the breakdown element created before the specified date
        :param str create_user: Search value for the breakdown element creator person
        :param str descr: Search pattern for the breakdown element description
        :param str edit_after: Search for the breakdown element edited after the specified date
        :param str edit_before: Search for the breakdown element edited before the specified date
        :param str edit_user: Search value for the breakdown element editor person
        :param int limit: Limit for the number of search result
        :param int node_id: Root element's instance ID of the branch to search within
        :param str node_ver: Version number of the element to search within
        :param str p_phase: Project phase to search within
        :param str pattern: Search pattern for the breakdown element name
        :param list[str] prop_name: List of the breakdown element property names to search for
        :param list[str] prop_val: List of the breakdown element property values to search for
        :param str type: Search pattern for the breakdown element type
        :return: list[BreakdownElementSearchResultInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'create_after', 'create_before', 'create_user', 'descr', 'edit_after', 'edit_before', 'edit_user', 'limit', 'node_id', 'node_ver', 'p_phase', 'pattern', 'prop_name', 'prop_val', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method advanced_search_node_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `advanced_search_node_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `advanced_search_node_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `advanced_search_node_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'create_after' in params:
            query_params.append(('createAfter', params['create_after']))  # noqa: E501
        if 'create_before' in params:
            query_params.append(('createBefore', params['create_before']))  # noqa: E501
        if 'create_user' in params:
            query_params.append(('createUser', params['create_user']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'edit_after' in params:
            query_params.append(('editAfter', params['edit_after']))  # noqa: E501
        if 'edit_before' in params:
            query_params.append(('editBefore', params['edit_before']))  # noqa: E501
        if 'edit_user' in params:
            query_params.append(('editUser', params['edit_user']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'node_id' in params:
            query_params.append(('nodeID', params['node_id']))  # noqa: E501
        if 'node_ver' in params:
            query_params.append(('nodeVer', params['node_ver']))  # noqa: E501
        if 'p_phase' in params:
            query_params.append(('pPhase', params['p_phase']))  # noqa: E501
        if 'pattern' in params:
            query_params.append(('pattern', params['pattern']))  # noqa: E501
        if 'prop_name' in params:
            query_params.append(('propName', params['prop_name']))  # noqa: E501
            collection_formats['propName'] = 'multi'  # noqa: E501
        if 'prop_val' in params:
            query_params.append(('propVal', params['prop_val']))  # noqa: E501
            collection_formats['propVal'] = 'multi'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/a_search/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BreakdownElementSearchResultInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def append_aggr_prop_csv_using_post(self, file, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Append values to the aggregated property in CSV format  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.append_aggr_prop_csv_using_post(file, model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.append_aggr_prop_csv_using_post_with_http_info(file, model, node, prop, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.append_aggr_prop_csv_using_post_with_http_info(file, model, node, prop, repository, token, **kwargs)  # noqa: E501
            return data

    def append_aggr_prop_csv_using_post_with_http_info(self, file, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Append values to the aggregated property in CSV format  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.append_aggr_prop_csv_using_post_with_http_info(file, model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'model', 'node', 'prop', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method append_aggr_prop_csv_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `append_aggr_prop_csv_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `append_aggr_prop_csv_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `append_aggr_prop_csv_using_post`")  # noqa: E501
        # verify the required parameter 'prop' is set
        if ('prop' not in params or
                params['prop'] is None):
            raise ValueError("Missing the required parameter `prop` when calling `append_aggr_prop_csv_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `append_aggr_prop_csv_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `append_aggr_prop_csv_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'prop' in params:
            path_params['prop'] = params['prop']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/aggr_csv/{repository}/{model}/{node}/{prop}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def append_aggr_prop_json_using_post(self, file, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Append values to the aggregated property in JSON format  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.append_aggr_prop_json_using_post(file, model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.append_aggr_prop_json_using_post_with_http_info(file, model, node, prop, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.append_aggr_prop_json_using_post_with_http_info(file, model, node, prop, repository, token, **kwargs)  # noqa: E501
            return data

    def append_aggr_prop_json_using_post_with_http_info(self, file, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Append values to the aggregated property in JSON format  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.append_aggr_prop_json_using_post_with_http_info(file, model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'model', 'node', 'prop', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method append_aggr_prop_json_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `append_aggr_prop_json_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `append_aggr_prop_json_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `append_aggr_prop_json_using_post`")  # noqa: E501
        # verify the required parameter 'prop' is set
        if ('prop' not in params or
                params['prop'] is None):
            raise ValueError("Missing the required parameter `prop` when calling `append_aggr_prop_json_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `append_aggr_prop_json_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `append_aggr_prop_json_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'prop' in params:
            path_params['prop'] = params['prop']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/aggr/{repository}/{model}/{node}/{prop}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_node_using_post(self, descr, model, name, node, repository, token, **kwargs):  # noqa: E501
        """Create new breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_node_using_post(descr, model, name, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str node_type: Node type
        :param str tmpl: Name of the breakdown template
        :return: BreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_node_using_post_with_http_info(descr, model, name, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.create_node_using_post_with_http_info(descr, model, name, node, repository, token, **kwargs)  # noqa: E501
            return data

    def create_node_using_post_with_http_info(self, descr, model, name, node, repository, token, **kwargs):  # noqa: E501
        """Create new breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_node_using_post_with_http_info(descr, model, name, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str node_type: Node type
        :param str tmpl: Name of the breakdown template
        :return: BreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['descr', 'model', 'name', 'node', 'repository', 'token', 'act_timestamp', 'node_type', 'tmpl']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'descr' is set
        if ('descr' not in params or
                params['descr'] is None):
            raise ValueError("Missing the required parameter `descr` when calling `create_node_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `create_node_using_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_node_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `create_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `create_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `create_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'node_type' in params:
            query_params.append(('nodeType', params['node_type']))  # noqa: E501
        if 'tmpl' in params:
            query_params.append(('tmpl', params['tmpl']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/create/{repository}/{model}/{node}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_root_node_using_post(self, descr, model, name, repository, token, **kwargs):  # noqa: E501
        """Create root element for the project's breakdown tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_root_node_using_post(descr, model, name, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str node_type: Node type
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_root_node_using_post_with_http_info(descr, model, name, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.create_root_node_using_post_with_http_info(descr, model, name, repository, token, **kwargs)  # noqa: E501
            return data

    def create_root_node_using_post_with_http_info(self, descr, model, name, repository, token, **kwargs):  # noqa: E501
        """Create root element for the project's breakdown tree  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_root_node_using_post_with_http_info(descr, model, name, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str node_type: Node type
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['descr', 'model', 'name', 'repository', 'token', 'node_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_root_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'descr' is set
        if ('descr' not in params or
                params['descr'] is None):
            raise ValueError("Missing the required parameter `descr` when calling `create_root_node_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `create_root_node_using_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `create_root_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `create_root_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `create_root_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'node_type' in params:
            query_params.append(('nodeType', params['node_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/root/{repository}/{model}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_node_using_delete(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Delete breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node_using_delete(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DeleteNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_node_using_delete_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_node_using_delete_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_node_using_delete_with_http_info(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Delete breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_node_using_delete_with_http_info(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DeleteNodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token', 'act_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_node_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_node_using_delete`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `delete_node_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_node_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_node_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/{repository}/{model}/{node}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeleteNodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_part_from_node_using_delete(self, model, node, prod, repository, token, **kwargs):  # noqa: E501
        """Delete product link from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_part_from_node_using_delete(model, node, prod, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param int prod: Instance ID of the representing_part or Product_view_definition of the product (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: RepresentingPartV
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_part_from_node_using_delete_with_http_info(model, node, prod, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_part_from_node_using_delete_with_http_info(model, node, prod, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_part_from_node_using_delete_with_http_info(self, model, node, prod, repository, token, **kwargs):  # noqa: E501
        """Delete product link from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_part_from_node_using_delete_with_http_info(model, node, prod, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param int prod: Instance ID of the representing_part or Product_view_definition of the product (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: RepresentingPartV
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'prod', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_part_from_node_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_part_from_node_using_delete`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `delete_part_from_node_using_delete`")  # noqa: E501
        # verify the required parameter 'prod' is set
        if ('prod' not in params or
                params['prod'] is None):
            raise ValueError("Missing the required parameter `prod` when calling `delete_part_from_node_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_part_from_node_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_part_from_node_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'prod' in params:
            query_params.append(('prod', params['prod']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/unit/{repository}/{model}/{node}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepresentingPartV',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_prop_vals_using_delete(self, model, prop, repository, token, **kwargs):  # noqa: E501
        """Remove property value from all breakdown elements in the last version with incrementing version of breakdown  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prop_vals_using_delete(model, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str prop: Property URN to delete (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str leave_for: Breakdown element type (subtype of remove_from if specified) where the property should be leaved
        :param str remove_from: Breakdown element type where the property should be removed
        :return: BreakdownElementSearchResultInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_prop_vals_using_delete_with_http_info(model, prop, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_prop_vals_using_delete_with_http_info(model, prop, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_prop_vals_using_delete_with_http_info(self, model, prop, repository, token, **kwargs):  # noqa: E501
        """Remove property value from all breakdown elements in the last version with incrementing version of breakdown  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_prop_vals_using_delete_with_http_info(model, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str prop: Property URN to delete (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str leave_for: Breakdown element type (subtype of remove_from if specified) where the property should be leaved
        :param str remove_from: Breakdown element type where the property should be removed
        :return: BreakdownElementSearchResultInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'prop', 'repository', 'token', 'act_timestamp', 'leave_for', 'remove_from']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_prop_vals_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_prop_vals_using_delete`")  # noqa: E501
        # verify the required parameter 'prop' is set
        if ('prop' not in params or
                params['prop'] is None):
            raise ValueError("Missing the required parameter `prop` when calling `delete_prop_vals_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_prop_vals_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_prop_vals_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'prop' in params:
            path_params['prop'] = params['prop']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'leave_for' in params:
            query_params.append(('leave_for', params['leave_for']))  # noqa: E501
        if 'remove_from' in params:
            query_params.append(('remove_from', params['remove_from']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/prop/{repository}/{model}/{prop}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementSearchResultInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_relationship_using_delete(self, model, rel, repository, token, **kwargs):  # noqa: E501
        """Delete specified relationship between breakdown elements  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_relationship_using_delete(model, rel, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int rel: Relationship instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: BeReferenceInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_relationship_using_delete_with_http_info(model, rel, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_relationship_using_delete_with_http_info(model, rel, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_relationship_using_delete_with_http_info(self, model, rel, repository, token, **kwargs):  # noqa: E501
        """Delete specified relationship between breakdown elements  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_relationship_using_delete_with_http_info(model, rel, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int rel: Relationship instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: BeReferenceInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'rel', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_relationship_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_relationship_using_delete`")  # noqa: E501
        # verify the required parameter 'rel' is set
        if ('rel' not in params or
                params['rel'] is None):
            raise ValueError("Missing the required parameter `rel` when calling `delete_relationship_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_relationship_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_relationship_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'rel' in params:
            path_params['rel'] = params['rel']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/rel/{repository}/{model}/{rel}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BeReferenceInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_node_using_post(self, descr, model, name, node, repository, token, **kwargs):  # noqa: E501
        """Edit breakdown element info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_node_using_post(descr, model, name, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str node_type: Node type
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_node_using_post_with_http_info(descr, model, name, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_node_using_post_with_http_info(descr, model, name, node, repository, token, **kwargs)  # noqa: E501
            return data

    def edit_node_using_post_with_http_info(self, descr, model, name, node, repository, token, **kwargs):  # noqa: E501
        """Edit breakdown element info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_node_using_post_with_http_info(descr, model, name, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str node_type: Node type
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['descr', 'model', 'name', 'node', 'repository', 'token', 'act_timestamp', 'node_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'descr' is set
        if ('descr' not in params or
                params['descr'] is None):
            raise ValueError("Missing the required parameter `descr` when calling `edit_node_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `edit_node_using_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `edit_node_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `edit_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `edit_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `edit_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'node_type' in params:
            query_params.append(('nodeType', params['node_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/edit/{repository}/{model}/{node}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_aggr_prop_body_using_get(self, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Return values of the aggregated property with filtering in JSON or CSV format  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_aggr_prop_body_using_get(model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] cols: List of columns
        :param str format: Data format for the exported file
        :param str _from: First value of the key for filtering
        :param str to: Last value of the key for filtering
        :return: FileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_aggr_prop_body_using_get_with_http_info(model, node, prop, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.export_aggr_prop_body_using_get_with_http_info(model, node, prop, repository, token, **kwargs)  # noqa: E501
            return data

    def export_aggr_prop_body_using_get_with_http_info(self, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Return values of the aggregated property with filtering in JSON or CSV format  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_aggr_prop_body_using_get_with_http_info(model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] cols: List of columns
        :param str format: Data format for the exported file
        :param str _from: First value of the key for filtering
        :param str to: Last value of the key for filtering
        :return: FileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'prop', 'repository', 'token', 'cols', 'format', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_aggr_prop_body_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `export_aggr_prop_body_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `export_aggr_prop_body_using_get`")  # noqa: E501
        # verify the required parameter 'prop' is set
        if ('prop' not in params or
                params['prop'] is None):
            raise ValueError("Missing the required parameter `prop` when calling `export_aggr_prop_body_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `export_aggr_prop_body_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `export_aggr_prop_body_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'prop' in params:
            path_params['prop'] = params['prop']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'cols' in params:
            query_params.append(('cols', params['cols']))  # noqa: E501
            collection_formats['cols'] = 'multi'  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/aggr_exp_dt/{repository}/{model}/{node}/{prop}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def export_aggr_prop_using_get(self, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Export values of the aggregated property with filtering to the JSON or CSV file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_aggr_prop_using_get(model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] cols: List of columns
        :param str format: Data format for the exported file
        :param str _from: First value of the key for filtering
        :param str to: Last value of the key for filtering
        :return: FileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.export_aggr_prop_using_get_with_http_info(model, node, prop, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.export_aggr_prop_using_get_with_http_info(model, node, prop, repository, token, **kwargs)  # noqa: E501
            return data

    def export_aggr_prop_using_get_with_http_info(self, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Export values of the aggregated property with filtering to the JSON or CSV file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.export_aggr_prop_using_get_with_http_info(model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] cols: List of columns
        :param str format: Data format for the exported file
        :param str _from: First value of the key for filtering
        :param str to: Last value of the key for filtering
        :return: FileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'prop', 'repository', 'token', 'cols', 'format', '_from', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method export_aggr_prop_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `export_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `export_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'prop' is set
        if ('prop' not in params or
                params['prop'] is None):
            raise ValueError("Missing the required parameter `prop` when calling `export_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `export_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `export_aggr_prop_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'prop' in params:
            path_params['prop'] = params['prop']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'cols' in params:
            query_params.append(('cols', params['cols']))  # noqa: E501
            collection_formats['cols'] = 'multi'  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/aggr_exp/{repository}/{model}/{node}/{prop}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_aggr_prop_using_get(self, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Return the values of the aggregated property with paging and filtering  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggr_prop_using_get(model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str _from: First value of the key for filtering
        :param int page: Current page number
        :param bool reverse_order: Use reverse order of the records
        :param int size: Number of the values on the page
        :param str to: Last value of the key for filtering
        :return: AggregatedProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_aggr_prop_using_get_with_http_info(model, node, prop, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_aggr_prop_using_get_with_http_info(model, node, prop, repository, token, **kwargs)  # noqa: E501
            return data

    def get_aggr_prop_using_get_with_http_info(self, model, node, prop, repository, token, **kwargs):  # noqa: E501
        """Return the values of the aggregated property with paging and filtering  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_aggr_prop_using_get_with_http_info(model, node, prop, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str prop: Aggregated property name (URN) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str _from: First value of the key for filtering
        :param int page: Current page number
        :param bool reverse_order: Use reverse order of the records
        :param int size: Number of the values on the page
        :param str to: Last value of the key for filtering
        :return: AggregatedProperty
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'prop', 'repository', 'token', '_from', 'page', 'reverse_order', 'size', 'to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_aggr_prop_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'prop' is set
        if ('prop' not in params or
                params['prop'] is None):
            raise ValueError("Missing the required parameter `prop` when calling `get_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_aggr_prop_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_aggr_prop_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'prop' in params:
            path_params['prop'] = params['prop']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if '_from' in params:
            query_params.append(('from', params['_from']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'reverse_order' in params:
            query_params.append(('reverse_order', params['reverse_order']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'to' in params:
            query_params.append(('to', params['to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/aggr/{repository}/{model}/{node}/{prop}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AggregatedProperty',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_assignment_using_get(self, inst, model, repository, token, **kwargs):  # noqa: E501
        """Return list of the assignment info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assignment_using_get(inst, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inst: Breakdown element instance ID (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[SimpleAssignment]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_assignment_using_get_with_http_info(inst, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_assignment_using_get_with_http_info(inst, model, repository, token, **kwargs)  # noqa: E501
            return data

    def get_assignment_using_get_with_http_info(self, inst, model, repository, token, **kwargs):  # noqa: E501
        """Return list of the assignment info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_assignment_using_get_with_http_info(inst, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inst: Breakdown element instance ID (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[SimpleAssignment]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inst', 'model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_assignment_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inst' is set
        if ('inst' not in params or
                params['inst'] is None):
            raise ValueError("Missing the required parameter `inst` when calling `get_assignment_using_get`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_assignment_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_assignment_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_assignment_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inst' in params:
            path_params['inst'] = params['inst']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/assign/{repository}/{model}/{inst}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SimpleAssignment]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_change_log_using_get(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return change log for the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_change_log_using_get(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int count: Number of the records in the report
        :param str end_dt: End date of the report
        :param int from_ind: Start record index of the report
        :param str start_dt: Start date of the report
        :return: list[ChangesLogItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_change_log_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_change_log_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def get_change_log_using_get_with_http_info(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return change log for the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_change_log_using_get_with_http_info(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int count: Number of the records in the report
        :param str end_dt: End date of the report
        :param int from_ind: Start record index of the report
        :param str start_dt: Start date of the report
        :return: list[ChangesLogItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token', 'count', 'end_dt', 'from_ind', 'start_dt']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_change_log_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_change_log_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_change_log_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_change_log_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_change_log_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'end_dt' in params:
            query_params.append(('endDt', params['end_dt']))  # noqa: E501
        if 'from_ind' in params:
            query_params.append(('fromInd', params['from_ind']))  # noqa: E501
        if 'start_dt' in params:
            query_params.append(('startDt', params['start_dt']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/chlog/{repository}/{model}/{node}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ChangesLogItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_diff_using_get(self, model, repository, token, tree1, tree2, **kwargs):  # noqa: E501
        """Return the comparison report of the two breakdown structures  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diff_using_get(model, repository, token, tree1, tree2, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str tree1: Identifier of the older structure (required)
        :param str tree2: Identifier of the newer structure (required)
        :param bool base1: Is the older structure baseline(true) or breakdown version(false)
        :param bool base2: Is the newer structure baseline(true) or breakdown version(false)
        :return: DiffReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_diff_using_get_with_http_info(model, repository, token, tree1, tree2, **kwargs)  # noqa: E501
        else:
            (data) = self.get_diff_using_get_with_http_info(model, repository, token, tree1, tree2, **kwargs)  # noqa: E501
            return data

    def get_diff_using_get_with_http_info(self, model, repository, token, tree1, tree2, **kwargs):  # noqa: E501
        """Return the comparison report of the two breakdown structures  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_diff_using_get_with_http_info(model, repository, token, tree1, tree2, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str tree1: Identifier of the older structure (required)
        :param str tree2: Identifier of the newer structure (required)
        :param bool base1: Is the older structure baseline(true) or breakdown version(false)
        :param bool base2: Is the newer structure baseline(true) or breakdown version(false)
        :return: DiffReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'tree1', 'tree2', 'base1', 'base2']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_diff_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_diff_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_diff_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_diff_using_get`")  # noqa: E501
        # verify the required parameter 'tree1' is set
        if ('tree1' not in params or
                params['tree1'] is None):
            raise ValueError("Missing the required parameter `tree1` when calling `get_diff_using_get`")  # noqa: E501
        # verify the required parameter 'tree2' is set
        if ('tree2' not in params or
                params['tree2'] is None):
            raise ValueError("Missing the required parameter `tree2` when calling `get_diff_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501
        if 'tree1' in params:
            path_params['tree1'] = params['tree1']  # noqa: E501
        if 'tree2' in params:
            path_params['tree2'] = params['tree2']  # noqa: E501

        query_params = []
        if 'base1' in params:
            query_params.append(('base1', params['base1']))  # noqa: E501
        if 'base2' in params:
            query_params.append(('base2', params['base2']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/diff/{repository}/{model}/{tree1}/{tree2}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DiffReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_history_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Return history report from the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_history_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int count: Number of the records in the report
        :param str end_dt: End date of the report
        :param int from_ind: Start record index of the report
        :param str start_dt: Start date of the report
        :return: list[HistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_history_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_history_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def get_history_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Return history report from the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_history_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int count: Number of the records in the report
        :param str end_dt: End date of the report
        :param int from_ind: Start record index of the report
        :param str start_dt: Start date of the report
        :return: list[HistoryItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'count', 'end_dt', 'from_ind', 'start_dt']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_history_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_history_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_history_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_history_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'end_dt' in params:
            query_params.append(('endDt', params['end_dt']))  # noqa: E501
        if 'from_ind' in params:
            query_params.append(('fromInd', params['from_ind']))  # noqa: E501
        if 'start_dt' in params:
            query_params.append(('startDt', params['start_dt']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/history/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HistoryItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_all_children_using_get(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return info about the children of the breakdown element with specified depth level  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_all_children_using_get(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str level: Depth level
        :param str ver: Breakdown version
        :return: SingleBreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_all_children_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_all_children_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def get_node_all_children_using_get_with_http_info(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return info about the children of the breakdown element with specified depth level  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_all_children_using_get_with_http_info(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str level: Depth level
        :param str ver: Breakdown version
        :return: SingleBreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token', 'level', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_all_children_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_node_all_children_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_node_all_children_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_node_all_children_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_node_all_children_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/full/{repository}/{model}/{node}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SingleBreakdownElementInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_children_opt_using_get(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return info about the children of the breakdown element with paging and options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_children_opt_using_get(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool asc_sort: Use ascending sorting
        :param str bsl: Baseline name
        :param int count: Number of the child elements from the start index
        :param int level: Depth level
        :param int opts: Bitwise mask of the following options                            0  : INCLUDE_BASIC_INFO_OPTION                            1  : INCLUDE_PROPERTIES_OPTION                            2  : INCLUDE_DERIVED_PROPERTIES_OPTION                            4  : INCLUDE_DOCUMENTS_OPTION                            8  : INCLUDE_PERMISSIONS_OPTION                            16 : INCLUDE_CREATION_OPTION                            32 : INCLUDE_RELATIONSHIP_OPTION
        :param str sort_attr: Element propery for the sorting
        :param int str_ind: Start index of the child elements
        :param str ver: Breakdown version
        :return: SingleBreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_children_opt_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_children_opt_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def get_node_children_opt_using_get_with_http_info(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return info about the children of the breakdown element with paging and options  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_children_opt_using_get_with_http_info(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool asc_sort: Use ascending sorting
        :param str bsl: Baseline name
        :param int count: Number of the child elements from the start index
        :param int level: Depth level
        :param int opts: Bitwise mask of the following options                            0  : INCLUDE_BASIC_INFO_OPTION                            1  : INCLUDE_PROPERTIES_OPTION                            2  : INCLUDE_DERIVED_PROPERTIES_OPTION                            4  : INCLUDE_DOCUMENTS_OPTION                            8  : INCLUDE_PERMISSIONS_OPTION                            16 : INCLUDE_CREATION_OPTION                            32 : INCLUDE_RELATIONSHIP_OPTION
        :param str sort_attr: Element propery for the sorting
        :param int str_ind: Start index of the child elements
        :param str ver: Breakdown version
        :return: SingleBreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token', 'asc_sort', 'bsl', 'count', 'level', 'opts', 'sort_attr', 'str_ind', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_children_opt_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_node_children_opt_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_node_children_opt_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_node_children_opt_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_node_children_opt_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'asc_sort' in params:
            query_params.append(('asc_sort', params['asc_sort']))  # noqa: E501
        if 'bsl' in params:
            query_params.append(('bsl', params['bsl']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'level' in params:
            query_params.append(('level', params['level']))  # noqa: E501
        if 'opts' in params:
            query_params.append(('opts', params['opts']))  # noqa: E501
        if 'sort_attr' in params:
            query_params.append(('sort_attr', params['sort_attr']))  # noqa: E501
        if 'str_ind' in params:
            query_params.append(('str_ind', params['str_ind']))  # noqa: E501
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/opt/{repository}/{model}/{node}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SingleBreakdownElementInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_children_using_get(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return info about the children of the breakdown element with paging  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_children_using_get(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool asc_sort: Use ascending sorting
        :param bool child_occur: Show child occurrences in list
        :param int count: Number of the child elements from the start index
        :param bool show_occur: Include occurences to the list
        :param bool show_shape: Include shape elements to the list
        :param str sort_attr: Element propery for the sorting
        :param int str_ind: Start index of the child elements
        :param str ver: Breakdown version
        :return: SingleBreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_children_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_children_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def get_node_children_using_get_with_http_info(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return info about the children of the breakdown element with paging  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_children_using_get_with_http_info(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool asc_sort: Use ascending sorting
        :param bool child_occur: Show child occurrences in list
        :param int count: Number of the child elements from the start index
        :param bool show_occur: Include occurences to the list
        :param bool show_shape: Include shape elements to the list
        :param str sort_attr: Element propery for the sorting
        :param int str_ind: Start index of the child elements
        :param str ver: Breakdown version
        :return: SingleBreakdownElementInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token', 'asc_sort', 'child_occur', 'count', 'show_occur', 'show_shape', 'sort_attr', 'str_ind', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_children_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_node_children_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_node_children_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_node_children_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_node_children_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'asc_sort' in params:
            query_params.append(('asc_sort', params['asc_sort']))  # noqa: E501
        if 'child_occur' in params:
            query_params.append(('child_occur', params['child_occur']))  # noqa: E501
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501
        if 'show_occur' in params:
            query_params.append(('show_occur', params['show_occur']))  # noqa: E501
        if 'show_shape' in params:
            query_params.append(('show_shape', params['show_shape']))  # noqa: E501
        if 'sort_attr' in params:
            query_params.append(('sort_attr', params['sort_attr']))  # noqa: E501
        if 'str_ind' in params:
            query_params.append(('str_ind', params['str_ind']))  # noqa: E501
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/{repository}/{model}/{node}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SingleBreakdownElementInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_path_using_get(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return path info from the root to the specified breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_path_using_get(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str id: ID of the breakdown element ( used if the specified instance ID equal 0 )
        :return: BreakdownElementSearchResultInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_path_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_path_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def get_node_path_using_get_with_http_info(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return path info from the root to the specified breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_path_using_get_with_http_info(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str id: ID of the breakdown element ( used if the specified instance ID equal 0 )
        :return: BreakdownElementSearchResultInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_path_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_node_path_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_node_path_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_node_path_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_node_path_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/search_path/{repository}/{model}/{node}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementSearchResultInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_relations_using_get(self, model, node, repository, token, type, **kwargs):  # noqa: E501
        """Return reference info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_relations_using_get(model, node, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Reference type (required)
        :param str role: Reference role
        :param str ver: Breakdown tree version
        :return: list[BeReferenceInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_relations_using_get_with_http_info(model, node, repository, token, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_relations_using_get_with_http_info(model, node, repository, token, type, **kwargs)  # noqa: E501
            return data

    def get_node_relations_using_get_with_http_info(self, model, node, repository, token, type, **kwargs):  # noqa: E501
        """Return reference info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_relations_using_get_with_http_info(model, node, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Reference type (required)
        :param str role: Reference role
        :param str ver: Breakdown tree version
        :return: list[BeReferenceInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token', 'type', 'role', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_relations_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_node_relations_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_node_relations_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_node_relations_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_node_relations_using_get`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_node_relations_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'role' in params:
            query_params.append(('role', params['role']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/rels/{repository}/{model}/{node}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BeReferenceInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_node_with_path_using_get(self, model, path, repository, token, **kwargs):  # noqa: E501
        """Return list of the breakdown elements according to the path from the root to the specified breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_with_path_using_get(model, path, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param list[int] path: Path to the breakdown element (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str ver: Breakdown version
        :return: list[BreakdownElementInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_node_with_path_using_get_with_http_info(model, path, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_node_with_path_using_get_with_http_info(model, path, repository, token, **kwargs)  # noqa: E501
            return data

    def get_node_with_path_using_get_with_http_info(self, model, path, repository, token, **kwargs):  # noqa: E501
        """Return list of the breakdown elements according to the path from the root to the specified breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_node_with_path_using_get_with_http_info(model, path, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param list[int] path: Path to the breakdown element (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str ver: Breakdown version
        :return: list[BreakdownElementInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'path', 'repository', 'token', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_node_with_path_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_node_with_path_using_get`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_node_with_path_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_node_with_path_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_node_with_path_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
            collection_formats['path'] = 'multi'  # noqa: E501
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/path/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BreakdownElementInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_relations_using_post(self, model, node, rels, repository, token, type, **kwargs):  # noqa: E501
        """Return reference info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_relations_using_post(model, node, rels, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param list[int] rels: List of the reference IDs (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Reference type (required)
        :return: list[BeReferenceInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_relations_using_post_with_http_info(model, node, rels, repository, token, type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_relations_using_post_with_http_info(model, node, rels, repository, token, type, **kwargs)  # noqa: E501
            return data

    def get_relations_using_post_with_http_info(self, model, node, rels, repository, token, type, **kwargs):  # noqa: E501
        """Return reference info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_relations_using_post_with_http_info(model, node, rels, repository, token, type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param list[int] rels: List of the reference IDs (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str type: Reference type (required)
        :return: list[BeReferenceInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'rels', 'repository', 'token', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_relations_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_relations_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `get_relations_using_post`")  # noqa: E501
        # verify the required parameter 'rels' is set
        if ('rels' not in params or
                params['rels'] is None):
            raise ValueError("Missing the required parameter `rels` when calling `get_relations_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_relations_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_relations_using_post`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_relations_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'rels' in params:
            query_params.append(('rels', params['rels']))  # noqa: E501
            collection_formats['rels'] = 'multi'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/rels/{repository}/{model}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BeReferenceInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_root_node_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Return the root breakdown element in the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_root_node_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str ver: Breakdown version
        :return: BreakdownInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_root_node_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_root_node_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def get_root_node_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Return the root breakdown element in the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_root_node_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str ver: Breakdown version
        :return: BreakdownInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_root_node_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_root_node_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_root_node_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_root_node_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_versions_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Return the list of breakdown tree versions in the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versions_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_versions_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_versions_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def get_versions_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Return the list of breakdown tree versions in the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_versions_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_versions_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_versions_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_versions_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_versions_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/versions/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inactivate_proj_using_put1(self, model, repository, token, **kwargs):  # noqa: E501
        """Increment project version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inactivate_proj_using_put1(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.inactivate_proj_using_put1_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.inactivate_proj_using_put1_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def inactivate_proj_using_put1_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Increment project version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inactivate_proj_using_put1_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inactivate_proj_using_put1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `inactivate_proj_using_put1`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `inactivate_proj_using_put1`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `inactivate_proj_using_put1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/ver/{repository}/{model}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_parts_in_node_using_get(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return list of the product links from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_parts_in_node_using_get(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[RepresentingPartV]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_parts_in_node_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.list_parts_in_node_using_get_with_http_info(model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def list_parts_in_node_using_get_with_http_info(self, model, node, repository, token, **kwargs):  # noqa: E501
        """Return list of the product links from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_parts_in_node_using_get_with_http_info(model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: list[RepresentingPartV]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_parts_in_node_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `list_parts_in_node_using_get`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `list_parts_in_node_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `list_parts_in_node_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `list_parts_in_node_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/unit/{repository}/{model}/{node}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RepresentingPartV]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_node_using_post(self, model, new_prn, node, repository, token, **kwargs):  # noqa: E501
        """Move/Copy breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_node_using_post(model, new_prn, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int new_prn: New parent breakdown element instance ID (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param bool copy: Use copy (true) or move (false) operation
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_node_using_post_with_http_info(model, new_prn, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.move_node_using_post_with_http_info(model, new_prn, node, repository, token, **kwargs)  # noqa: E501
            return data

    def move_node_using_post_with_http_info(self, model, new_prn, node, repository, token, **kwargs):  # noqa: E501
        """Move/Copy breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_node_using_post_with_http_info(model, new_prn, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int new_prn: New parent breakdown element instance ID (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param bool copy: Use copy (true) or move (false) operation
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'new_prn', 'node', 'repository', 'token', 'act_timestamp', 'copy']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `move_node_using_post`")  # noqa: E501
        # verify the required parameter 'new_prn' is set
        if ('new_prn' not in params or
                params['new_prn'] is None):
            raise ValueError("Missing the required parameter `new_prn` when calling `move_node_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `move_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `move_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `move_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'new_prn' in params:
            path_params['newPrn'] = params['new_prn']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'copy' in params:
            query_params.append(('copy', params['copy']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/{repository}/{model}/{node}/{newPrn}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quick_search_using_get(self, model, pattern, repository, token, **kwargs):  # noqa: E501
        """Search breakbown elements by string pattern  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quick_search_using_get(model, pattern, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str pattern: Search string pattern (for LIKE operations in EXPRESS) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool case_sens: Use case sensitive search or not
        :param str domains: CSV list of subjects for search, can include ID, DESCRIPTION, CLASS, PROPERY
        :param bool folder_only: Return only direct children of parent_folder
        :param int node: Breakdown element instance id - root of interesting branch
        :param int page: Start page of output
        :param int page_size: Page size of output
        :param str props: CSV list of property names where to apply search pattern (when PROPERTY is listed)
        :return: list[BreakdownElementSearchResultInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quick_search_using_get_with_http_info(model, pattern, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.quick_search_using_get_with_http_info(model, pattern, repository, token, **kwargs)  # noqa: E501
            return data

    def quick_search_using_get_with_http_info(self, model, pattern, repository, token, **kwargs):  # noqa: E501
        """Search breakbown elements by string pattern  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quick_search_using_get_with_http_info(model, pattern, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str pattern: Search string pattern (for LIKE operations in EXPRESS) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool case_sens: Use case sensitive search or not
        :param str domains: CSV list of subjects for search, can include ID, DESCRIPTION, CLASS, PROPERY
        :param bool folder_only: Return only direct children of parent_folder
        :param int node: Breakdown element instance id - root of interesting branch
        :param int page: Start page of output
        :param int page_size: Page size of output
        :param str props: CSV list of property names where to apply search pattern (when PROPERTY is listed)
        :return: list[BreakdownElementSearchResultInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'pattern', 'repository', 'token', 'case_sens', 'domains', 'folder_only', 'node', 'page', 'page_size', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quick_search_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `quick_search_using_get`")  # noqa: E501
        # verify the required parameter 'pattern' is set
        if ('pattern' not in params or
                params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `quick_search_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `quick_search_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `quick_search_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'case_sens' in params:
            query_params.append(('case_sens', params['case_sens']))  # noqa: E501
        if 'domains' in params:
            query_params.append(('domains', params['domains']))  # noqa: E501
        if 'folder_only' in params:
            query_params.append(('folder_only', params['folder_only']))  # noqa: E501
        if 'node' in params:
            query_params.append(('node', params['node']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'pattern' in params:
            query_params.append(('pattern', params['pattern']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/q_search/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BreakdownElementSearchResultInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rename_node_using_post(self, descr, model, name, node, repository, token, **kwargs):  # noqa: E501
        """Rename breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_node_using_post(descr, model, name, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str node_type: Node type
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.rename_node_using_post_with_http_info(descr, model, name, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.rename_node_using_post_with_http_info(descr, model, name, node, repository, token, **kwargs)  # noqa: E501
            return data

    def rename_node_using_post_with_http_info(self, descr, model, name, node, repository, token, **kwargs):  # noqa: E501
        """Rename breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_node_using_post_with_http_info(descr, model, name, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str descr: Node/Project description (required)
        :param str model: Model name (required)
        :param str name: Node/Project name (required)
        :param int node: Breakdown element instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param str node_type: Node type
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['descr', 'model', 'name', 'node', 'repository', 'token', 'act_timestamp', 'node_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'descr' is set
        if ('descr' not in params or
                params['descr'] is None):
            raise ValueError("Missing the required parameter `descr` when calling `rename_node_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `rename_node_using_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `rename_node_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `rename_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `rename_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `rename_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'node_type' in params:
            query_params.append(('nodeType', params['node_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/{repository}/{model}/{node}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prop_using_post(self, model, node, props, ptypes, repository, token, vals, **kwargs):  # noqa: E501
        """Update user defined properties of the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prop_using_post(model, node, props, ptypes, repository, token, vals, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param list[str] props: Property names (required)
        :param list[str] ptypes: Property types. T - text, N - numeric, D - data, B - boolean (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] vals: Property values (required)
        :param int act_timestamp: Timestamp of the request
        :param list[str] units: Property unites
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prop_using_post_with_http_info(model, node, props, ptypes, repository, token, vals, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prop_using_post_with_http_info(model, node, props, ptypes, repository, token, vals, **kwargs)  # noqa: E501
            return data

    def update_prop_using_post_with_http_info(self, model, node, props, ptypes, repository, token, vals, **kwargs):  # noqa: E501
        """Update user defined properties of the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prop_using_post_with_http_info(model, node, props, ptypes, repository, token, vals, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int node: Breakdown element instance ID (required)
        :param list[str] props: Property names (required)
        :param list[str] ptypes: Property types. T - text, N - numeric, D - data, B - boolean (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] vals: Property values (required)
        :param int act_timestamp: Timestamp of the request
        :param list[str] units: Property unites
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'node', 'props', 'ptypes', 'repository', 'token', 'vals', 'act_timestamp', 'units']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prop_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `update_prop_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `update_prop_using_post`")  # noqa: E501
        # verify the required parameter 'props' is set
        if ('props' not in params or
                params['props'] is None):
            raise ValueError("Missing the required parameter `props` when calling `update_prop_using_post`")  # noqa: E501
        # verify the required parameter 'ptypes' is set
        if ('ptypes' not in params or
                params['ptypes'] is None):
            raise ValueError("Missing the required parameter `ptypes` when calling `update_prop_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `update_prop_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_prop_using_post`")  # noqa: E501
        # verify the required parameter 'vals' is set
        if ('vals' not in params or
                params['vals'] is None):
            raise ValueError("Missing the required parameter `vals` when calling `update_prop_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501
            collection_formats['props'] = 'multi'  # noqa: E501
        if 'ptypes' in params:
            query_params.append(('ptypes', params['ptypes']))  # noqa: E501
            collection_formats['ptypes'] = 'multi'  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
            collection_formats['units'] = 'multi'  # noqa: E501
        if 'vals' in params:
            query_params.append(('vals', params['vals']))  # noqa: E501
            collection_formats['vals'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/prop/{repository}/{model}/{node}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_relation_to_node_using_post(self, model, rel, repository, token, **kwargs):  # noqa: E501
        """Update relationship from parent breakdown element to child breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_relation_to_node_using_post(model, rel, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int rel: Relationship instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str remark: Remark text
        :param str title1: title1
        :param str title2: Related element title
        :return: BeReferenceInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_relation_to_node_using_post_with_http_info(model, rel, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.update_relation_to_node_using_post_with_http_info(model, rel, repository, token, **kwargs)  # noqa: E501
            return data

    def update_relation_to_node_using_post_with_http_info(self, model, rel, repository, token, **kwargs):  # noqa: E501
        """Update relationship from parent breakdown element to child breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_relation_to_node_using_post_with_http_info(model, rel, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int rel: Relationship instance ID (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str remark: Remark text
        :param str title1: title1
        :param str title2: Related element title
        :return: BeReferenceInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'rel', 'repository', 'token', 'remark', 'title1', 'title2']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_relation_to_node_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `update_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'rel' is set
        if ('rel' not in params or
                params['rel'] is None):
            raise ValueError("Missing the required parameter `rel` when calling `update_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `update_relation_to_node_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_relation_to_node_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'rel' in params:
            path_params['rel'] = params['rel']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'remark' in params:
            query_params.append(('remark', params['remark']))  # noqa: E501
        if 'title1' in params:
            query_params.append(('title1', params['title1']))  # noqa: E501
        if 'title2' in params:
            query_params.append(('title2', params['title2']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/bkd/rel_up/{repository}/{model}/{rel}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BeReferenceInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
