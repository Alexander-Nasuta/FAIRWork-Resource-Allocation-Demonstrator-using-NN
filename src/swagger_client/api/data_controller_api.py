# coding: utf-8

"""
    Api Documentation

    Api Documentation  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DataControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_file_using_post(self, file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, model, node, repository, token, **kwargs):  # noqa: E501
        """Add document to the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_file_using_post(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str app: Login of person, who approved the document (required)
        :param str content_type: Content type of the document (required)
        :param str descr: Description of the document (required)
        :param str discipline: Discipline of the document (required)
        :param str editor: Login of person, who edited the document (required)
        :param bool is_new_issue: Is it the new major version of the document (required)
        :param str proj_phase: Project phase of the document (required)
        :param str resp: Login of person, who responsible for the document (required)
        :param str rev: Login of person, who reviewed the document (required)
        :param str rev_man: Login of person, who is the release manager for the document (required)
        :param str source: Source of the document (required)
        :param str status: Status of the document (required)
        :param str title: Title of the document (required)
        :param str model: Model name (required)
        :param int node: Instance ID of the breakdown element (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_file_using_post_with_http_info(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, model, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.add_file_using_post_with_http_info(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, model, node, repository, token, **kwargs)  # noqa: E501
            return data

    def add_file_using_post_with_http_info(self, file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, model, node, repository, token, **kwargs):  # noqa: E501
        """Add document to the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_file_using_post_with_http_info(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, model, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str app: Login of person, who approved the document (required)
        :param str content_type: Content type of the document (required)
        :param str descr: Description of the document (required)
        :param str discipline: Discipline of the document (required)
        :param str editor: Login of person, who edited the document (required)
        :param bool is_new_issue: Is it the new major version of the document (required)
        :param str proj_phase: Project phase of the document (required)
        :param str resp: Login of person, who responsible for the document (required)
        :param str rev: Login of person, who reviewed the document (required)
        :param str rev_man: Login of person, who is the release manager for the document (required)
        :param str source: Source of the document (required)
        :param str status: Status of the document (required)
        :param str title: Title of the document (required)
        :param str model: Model name (required)
        :param int node: Instance ID of the breakdown element (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'app', 'content_type', 'descr', 'discipline', 'editor', 'is_new_issue', 'proj_phase', 'resp', 'rev', 'rev_man', 'source', 'status', 'title', 'model', 'node', 'repository', 'token', 'act_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_file_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if ('app' not in params or
                params['app'] is None):
            raise ValueError("Missing the required parameter `app` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'descr' is set
        if ('descr' not in params or
                params['descr'] is None):
            raise ValueError("Missing the required parameter `descr` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'discipline' is set
        if ('discipline' not in params or
                params['discipline'] is None):
            raise ValueError("Missing the required parameter `discipline` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'editor' is set
        if ('editor' not in params or
                params['editor'] is None):
            raise ValueError("Missing the required parameter `editor` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'is_new_issue' is set
        if ('is_new_issue' not in params or
                params['is_new_issue'] is None):
            raise ValueError("Missing the required parameter `is_new_issue` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'proj_phase' is set
        if ('proj_phase' not in params or
                params['proj_phase'] is None):
            raise ValueError("Missing the required parameter `proj_phase` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'resp' is set
        if ('resp' not in params or
                params['resp'] is None):
            raise ValueError("Missing the required parameter `resp` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'rev' is set
        if ('rev' not in params or
                params['rev'] is None):
            raise ValueError("Missing the required parameter `rev` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'rev_man' is set
        if ('rev_man' not in params or
                params['rev_man'] is None):
            raise ValueError("Missing the required parameter `rev_man` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'source' is set
        if ('source' not in params or
                params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'status' is set
        if ('status' not in params or
                params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'title' is set
        if ('title' not in params or
                params['title'] is None):
            raise ValueError("Missing the required parameter `title` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `add_file_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `add_file_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'content_type' in params:
            query_params.append(('contentType', params['content_type']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'discipline' in params:
            query_params.append(('discipline', params['discipline']))  # noqa: E501
        if 'editor' in params:
            query_params.append(('editor', params['editor']))  # noqa: E501
        if 'is_new_issue' in params:
            query_params.append(('isNewIssue', params['is_new_issue']))  # noqa: E501
        if 'proj_phase' in params:
            query_params.append(('projPhase', params['proj_phase']))  # noqa: E501
        if 'resp' in params:
            query_params.append(('resp', params['resp']))  # noqa: E501
        if 'rev' in params:
            query_params.append(('rev', params['rev']))  # noqa: E501
        if 'rev_man' in params:
            query_params.append(('revMan', params['rev_man']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/{repository}/{model}/{node}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataFileInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_note_using_post(self, content, file, model, repository, token, ver, **kwargs):  # noqa: E501
        """Add sticky note to the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_note_using_post(content, file, model, repository, token, ver, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content: Content of the sticky note (required)
        :param int file: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str ver: Version number of the document (required)
        :return: StickyNoteInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_note_using_post_with_http_info(content, file, model, repository, token, ver, **kwargs)  # noqa: E501
        else:
            (data) = self.add_note_using_post_with_http_info(content, file, model, repository, token, ver, **kwargs)  # noqa: E501
            return data

    def add_note_using_post_with_http_info(self, content, file, model, repository, token, ver, **kwargs):  # noqa: E501
        """Add sticky note to the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_note_using_post_with_http_info(content, file, model, repository, token, ver, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str content: Content of the sticky note (required)
        :param int file: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str ver: Version number of the document (required)
        :return: StickyNoteInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['content', 'file', 'model', 'repository', 'token', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_note_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'content' is set
        if ('content' not in params or
                params['content'] is None):
            raise ValueError("Missing the required parameter `content` when calling `add_note_using_post`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `add_note_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `add_note_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `add_note_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `add_note_using_post`")  # noqa: E501
        # verify the required parameter 'ver' is set
        if ('ver' not in params or
                params['ver'] is None):
            raise ValueError("Missing the required parameter `ver` when calling `add_note_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file' in params:
            path_params['file'] = params['file']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'content' in params:
            query_params.append(('content', params['content']))  # noqa: E501
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/note/{repository}/{model}/{file}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StickyNoteInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def advanced_search_documents_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Advanced search for the documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.advanced_search_documents_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str approver: Search value for the document approver person
        :param str check_out_user: Search for the documents checked out by the specified person
        :param str create_after: Search for the document created after the specified date
        :param str create_before: Search for the document created before the specified date
        :param str create_user: Search for the documents created by the specified person
        :param str data_type: Search value for the document data type
        :param str descipline: Search value for the document discipline
        :param str descr: Search pattern for the document description
        :param str doc_source: Search value for the document source
        :param str doc_status: Search value for the document status
        :param str doc_type: Search value for the document type
        :param str edit_after: Search for the document edited after the specified date
        :param str edit_before: Search for the document edited before the specified date
        :param str edit_user: Search for the documents edited by the specified person
        :param str editor: Search value for the document editor person
        :param str ext_ver: Search value for the document external version
        :param int limit: Limit for the number of search result
        :param int node_id: Root element's instance ID of the branch to search within
        :param str node_ver: Version number of the element to search within
        :param bool only_check_out: Search for the checked out documents only
        :param bool only_red_flag: Search for the documents with the read flag only
        :param bool only_sticky_note: Search for the documents with the sticky notes only
        :param str p_phase: Search value for the document project phase
        :param list[str] prop_name: List of the document property names to search for
        :param list[str] prop_val: List of the document property values to search for
        :param str r_manager: Search value for the document release manager person
        :param str responsible: Search value for the document responsible person
        :param str reviewer: Search value for the document reviewer person
        :param str rid: Search value for the document RID
        :param str submit_after: Search for the document submitted after the specified date
        :param str submit_before: Search for the document submitted before the specified date
        :param str title: Search pattern for the document title
        :return: list[DataFileSearchResultInfoEx]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.advanced_search_documents_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.advanced_search_documents_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def advanced_search_documents_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Advanced search for the documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.advanced_search_documents_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str approver: Search value for the document approver person
        :param str check_out_user: Search for the documents checked out by the specified person
        :param str create_after: Search for the document created after the specified date
        :param str create_before: Search for the document created before the specified date
        :param str create_user: Search for the documents created by the specified person
        :param str data_type: Search value for the document data type
        :param str descipline: Search value for the document discipline
        :param str descr: Search pattern for the document description
        :param str doc_source: Search value for the document source
        :param str doc_status: Search value for the document status
        :param str doc_type: Search value for the document type
        :param str edit_after: Search for the document edited after the specified date
        :param str edit_before: Search for the document edited before the specified date
        :param str edit_user: Search for the documents edited by the specified person
        :param str editor: Search value for the document editor person
        :param str ext_ver: Search value for the document external version
        :param int limit: Limit for the number of search result
        :param int node_id: Root element's instance ID of the branch to search within
        :param str node_ver: Version number of the element to search within
        :param bool only_check_out: Search for the checked out documents only
        :param bool only_red_flag: Search for the documents with the read flag only
        :param bool only_sticky_note: Search for the documents with the sticky notes only
        :param str p_phase: Search value for the document project phase
        :param list[str] prop_name: List of the document property names to search for
        :param list[str] prop_val: List of the document property values to search for
        :param str r_manager: Search value for the document release manager person
        :param str responsible: Search value for the document responsible person
        :param str reviewer: Search value for the document reviewer person
        :param str rid: Search value for the document RID
        :param str submit_after: Search for the document submitted after the specified date
        :param str submit_before: Search for the document submitted before the specified date
        :param str title: Search pattern for the document title
        :return: list[DataFileSearchResultInfoEx]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'approver', 'check_out_user', 'create_after', 'create_before', 'create_user', 'data_type', 'descipline', 'descr', 'doc_source', 'doc_status', 'doc_type', 'edit_after', 'edit_before', 'edit_user', 'editor', 'ext_ver', 'limit', 'node_id', 'node_ver', 'only_check_out', 'only_red_flag', 'only_sticky_note', 'p_phase', 'prop_name', 'prop_val', 'r_manager', 'responsible', 'reviewer', 'rid', 'submit_after', 'submit_before', 'title']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method advanced_search_documents_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `advanced_search_documents_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `advanced_search_documents_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `advanced_search_documents_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'approver' in params:
            query_params.append(('approver', params['approver']))  # noqa: E501
        if 'check_out_user' in params:
            query_params.append(('checkOutUser', params['check_out_user']))  # noqa: E501
        if 'create_after' in params:
            query_params.append(('createAfter', params['create_after']))  # noqa: E501
        if 'create_before' in params:
            query_params.append(('createBefore', params['create_before']))  # noqa: E501
        if 'create_user' in params:
            query_params.append(('createUser', params['create_user']))  # noqa: E501
        if 'data_type' in params:
            query_params.append(('dataType', params['data_type']))  # noqa: E501
        if 'descipline' in params:
            query_params.append(('descipline', params['descipline']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'doc_source' in params:
            query_params.append(('docSource', params['doc_source']))  # noqa: E501
        if 'doc_status' in params:
            query_params.append(('docStatus', params['doc_status']))  # noqa: E501
        if 'doc_type' in params:
            query_params.append(('docType', params['doc_type']))  # noqa: E501
        if 'edit_after' in params:
            query_params.append(('editAfter', params['edit_after']))  # noqa: E501
        if 'edit_before' in params:
            query_params.append(('editBefore', params['edit_before']))  # noqa: E501
        if 'edit_user' in params:
            query_params.append(('editUser', params['edit_user']))  # noqa: E501
        if 'editor' in params:
            query_params.append(('editor', params['editor']))  # noqa: E501
        if 'ext_ver' in params:
            query_params.append(('extVer', params['ext_ver']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'node_id' in params:
            query_params.append(('nodeID', params['node_id']))  # noqa: E501
        if 'node_ver' in params:
            query_params.append(('nodeVer', params['node_ver']))  # noqa: E501
        if 'only_check_out' in params:
            query_params.append(('onlyCheckOut', params['only_check_out']))  # noqa: E501
        if 'only_red_flag' in params:
            query_params.append(('onlyRedFlag', params['only_red_flag']))  # noqa: E501
        if 'only_sticky_note' in params:
            query_params.append(('onlyStickyNote', params['only_sticky_note']))  # noqa: E501
        if 'p_phase' in params:
            query_params.append(('pPhase', params['p_phase']))  # noqa: E501
        if 'prop_name' in params:
            query_params.append(('propName', params['prop_name']))  # noqa: E501
            collection_formats['propName'] = 'multi'  # noqa: E501
        if 'prop_val' in params:
            query_params.append(('propVal', params['prop_val']))  # noqa: E501
            collection_formats['propVal'] = 'multi'  # noqa: E501
        if 'r_manager' in params:
            query_params.append(('rManager', params['r_manager']))  # noqa: E501
        if 'responsible' in params:
            query_params.append(('responsible', params['responsible']))  # noqa: E501
        if 'reviewer' in params:
            query_params.append(('reviewer', params['reviewer']))  # noqa: E501
        if 'rid' in params:
            query_params.append(('rid', params['rid']))  # noqa: E501
        if 'submit_after' in params:
            query_params.append(('submitAfter', params['submit_after']))  # noqa: E501
        if 'submit_before' in params:
            query_params.append(('submitBefore', params['submit_before']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/a_search/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DataFileSearchResultInfoEx]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_in_file_using_post(self, file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, in_file, model, repository, token, **kwargs):  # noqa: E501
        """Check In document operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_in_file_using_post(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, in_file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str app: Login of person, who approved the document (required)
        :param str content_type: Content type of the document (required)
        :param str descr: Description of the document (required)
        :param str discipline: Discipline of the document (required)
        :param str editor: Login of person, who edited the document (required)
        :param bool is_new_issue: Is it the new major version of the document (required)
        :param str proj_phase: Project phase of the document (required)
        :param str resp: Login of person, who responsible for the document (required)
        :param str rev: Login of person, who reviewed the document (required)
        :param str rev_man: Login of person, who is the release manager for the document (required)
        :param str source: Source of the document (required)
        :param str status: Status of the document (required)
        :param str title: Title of the document (required)
        :param int in_file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_in_file_using_post_with_http_info(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, in_file, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.check_in_file_using_post_with_http_info(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, in_file, model, repository, token, **kwargs)  # noqa: E501
            return data

    def check_in_file_using_post_with_http_info(self, file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, in_file, model, repository, token, **kwargs):  # noqa: E501
        """Check In document operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_in_file_using_post_with_http_info(file, app, content_type, descr, discipline, editor, is_new_issue, proj_phase, resp, rev, rev_man, source, status, title, in_file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file: (required)
        :param str app: Login of person, who approved the document (required)
        :param str content_type: Content type of the document (required)
        :param str descr: Description of the document (required)
        :param str discipline: Discipline of the document (required)
        :param str editor: Login of person, who edited the document (required)
        :param bool is_new_issue: Is it the new major version of the document (required)
        :param str proj_phase: Project phase of the document (required)
        :param str resp: Login of person, who responsible for the document (required)
        :param str rev: Login of person, who reviewed the document (required)
        :param str rev_man: Login of person, who is the release manager for the document (required)
        :param str source: Source of the document (required)
        :param str status: Status of the document (required)
        :param str title: Title of the document (required)
        :param int in_file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'app', 'content_type', 'descr', 'discipline', 'editor', 'is_new_issue', 'proj_phase', 'resp', 'rev', 'rev_man', 'source', 'status', 'title', 'in_file', 'model', 'repository', 'token', 'act_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_in_file_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'app' is set
        if ('app' not in params or
                params['app'] is None):
            raise ValueError("Missing the required parameter `app` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if ('content_type' not in params or
                params['content_type'] is None):
            raise ValueError("Missing the required parameter `content_type` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'descr' is set
        if ('descr' not in params or
                params['descr'] is None):
            raise ValueError("Missing the required parameter `descr` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'discipline' is set
        if ('discipline' not in params or
                params['discipline'] is None):
            raise ValueError("Missing the required parameter `discipline` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'editor' is set
        if ('editor' not in params or
                params['editor'] is None):
            raise ValueError("Missing the required parameter `editor` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'is_new_issue' is set
        if ('is_new_issue' not in params or
                params['is_new_issue'] is None):
            raise ValueError("Missing the required parameter `is_new_issue` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'proj_phase' is set
        if ('proj_phase' not in params or
                params['proj_phase'] is None):
            raise ValueError("Missing the required parameter `proj_phase` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'resp' is set
        if ('resp' not in params or
                params['resp'] is None):
            raise ValueError("Missing the required parameter `resp` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'rev' is set
        if ('rev' not in params or
                params['rev'] is None):
            raise ValueError("Missing the required parameter `rev` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'rev_man' is set
        if ('rev_man' not in params or
                params['rev_man'] is None):
            raise ValueError("Missing the required parameter `rev_man` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'source' is set
        if ('source' not in params or
                params['source'] is None):
            raise ValueError("Missing the required parameter `source` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'status' is set
        if ('status' not in params or
                params['status'] is None):
            raise ValueError("Missing the required parameter `status` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'title' is set
        if ('title' not in params or
                params['title'] is None):
            raise ValueError("Missing the required parameter `title` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'in_file' is set
        if ('in_file' not in params or
                params['in_file'] is None):
            raise ValueError("Missing the required parameter `in_file` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `check_in_file_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `check_in_file_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'in_file' in params:
            path_params['inFile'] = params['in_file']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'app' in params:
            query_params.append(('app', params['app']))  # noqa: E501
        if 'content_type' in params:
            query_params.append(('contentType', params['content_type']))  # noqa: E501
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'discipline' in params:
            query_params.append(('discipline', params['discipline']))  # noqa: E501
        if 'editor' in params:
            query_params.append(('editor', params['editor']))  # noqa: E501
        if 'is_new_issue' in params:
            query_params.append(('isNewIssue', params['is_new_issue']))  # noqa: E501
        if 'proj_phase' in params:
            query_params.append(('projPhase', params['proj_phase']))  # noqa: E501
        if 'resp' in params:
            query_params.append(('resp', params['resp']))  # noqa: E501
        if 'rev' in params:
            query_params.append(('rev', params['rev']))  # noqa: E501
        if 'rev_man' in params:
            query_params.append(('revMan', params['rev_man']))  # noqa: E501
        if 'source' in params:
            query_params.append(('source', params['source']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/file_checkin/{repository}/{model}/{inFile}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataFileInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def checkout_file_using_put(self, file, model, repository, token, **kwargs):  # noqa: E501
        """Check Out document operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.checkout_file_using_put(file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.checkout_file_using_put_with_http_info(file, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.checkout_file_using_put_with_http_info(file, model, repository, token, **kwargs)  # noqa: E501
            return data

    def checkout_file_using_put_with_http_info(self, file, model, repository, token, **kwargs):  # noqa: E501
        """Check Out document operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.checkout_file_using_put_with_http_info(file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'model', 'repository', 'token', 'act_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method checkout_file_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `checkout_file_using_put`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `checkout_file_using_put`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `checkout_file_using_put`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `checkout_file_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file' in params:
            path_params['file'] = params['file']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/file_checkout/{repository}/{model}/{file}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataFileInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clear_red_flag_using_put(self, depfile, file, model, repository, token, **kwargs):  # noqa: E501
        """Clear red flag on the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_red_flag_using_put(depfile, file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int depfile: Instance ID of the affected document's current version (required)
        :param int file: Instance ID of the affecting document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clear_red_flag_using_put_with_http_info(depfile, file, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.clear_red_flag_using_put_with_http_info(depfile, file, model, repository, token, **kwargs)  # noqa: E501
            return data

    def clear_red_flag_using_put_with_http_info(self, depfile, file, model, repository, token, **kwargs):  # noqa: E501
        """Clear red flag on the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clear_red_flag_using_put_with_http_info(depfile, file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int depfile: Instance ID of the affected document's current version (required)
        :param int file: Instance ID of the affecting document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['depfile', 'file', 'model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clear_red_flag_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'depfile' is set
        if ('depfile' not in params or
                params['depfile'] is None):
            raise ValueError("Missing the required parameter `depfile` when calling `clear_red_flag_using_put`")  # noqa: E501
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `clear_red_flag_using_put`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `clear_red_flag_using_put`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `clear_red_flag_using_put`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `clear_red_flag_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'depfile' in params:
            path_params['depfile'] = params['depfile']  # noqa: E501
        if 'file' in params:
            path_params['file'] = params['file']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/flag/{repository}/{model}/{file}/{depfile}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_file_using_delete(self, doc, model, repository, token, **kwargs):  # noqa: E501
        """Delete document from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_using_delete(doc, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param bool all: Delete document and all relations
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_file_using_delete_with_http_info(doc, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_file_using_delete_with_http_info(doc, model, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_file_using_delete_with_http_info(self, doc, model, repository, token, **kwargs):  # noqa: E501
        """Delete document from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_file_using_delete_with_http_info(doc, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param bool all: Delete document and all relations
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc', 'model', 'repository', 'token', 'act_timestamp', 'all']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_file_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'doc' is set
        if ('doc' not in params or
                params['doc'] is None):
            raise ValueError("Missing the required parameter `doc` when calling `delete_file_using_delete`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_file_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_file_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_file_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'doc' in params:
            path_params['doc'] = params['doc']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'all' in params:
            query_params.append(('all', params['all']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/{repository}/{model}/{doc}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_files_using_delete(self, docs, model, repository, token, **kwargs):  # noqa: E501
        """Delete a list of documents from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_files_using_delete(docs, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] docs: Instance IDs of the document assignments (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param bool all: Delete documents with all reletions
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_files_using_delete_with_http_info(docs, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_files_using_delete_with_http_info(docs, model, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_files_using_delete_with_http_info(self, docs, model, repository, token, **kwargs):  # noqa: E501
        """Delete a list of documents from the breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_files_using_delete_with_http_info(docs, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[int] docs: Instance IDs of the document assignments (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :param bool all: Delete documents with all reletions
        :return: BreakdownElementInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['docs', 'model', 'repository', 'token', 'act_timestamp', 'all']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_files_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'docs' is set
        if ('docs' not in params or
                params['docs'] is None):
            raise ValueError("Missing the required parameter `docs` when calling `delete_files_using_delete`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_files_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_files_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_files_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'all' in params:
            query_params.append(('all', params['all']))  # noqa: E501
        if 'docs' in params:
            query_params.append(('docs', params['docs']))  # noqa: E501
            collection_formats['docs'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/docs/{repository}/{model}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BreakdownElementInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_link_using_delete(self, file1, file2, model, repository, token, **kwargs):  # noqa: E501
        """Delete documents relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_link_using_delete(file1, file2, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file1: Instance ID of the affecting document's current version (required)
        :param int file2: Instance ID of the affected document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_link_using_delete_with_http_info(file1, file2, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_link_using_delete_with_http_info(file1, file2, model, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_link_using_delete_with_http_info(self, file1, file2, model, repository, token, **kwargs):  # noqa: E501
        """Delete documents relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_link_using_delete_with_http_info(file1, file2, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file1: Instance ID of the affecting document's current version (required)
        :param int file2: Instance ID of the affected document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file1', 'file2', 'model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_link_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file1' is set
        if ('file1' not in params or
                params['file1'] is None):
            raise ValueError("Missing the required parameter `file1` when calling `delete_link_using_delete`")  # noqa: E501
        # verify the required parameter 'file2' is set
        if ('file2' not in params or
                params['file2'] is None):
            raise ValueError("Missing the required parameter `file2` when calling `delete_link_using_delete`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_link_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_link_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_link_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file1' in params:
            path_params['file1'] = params['file1']  # noqa: E501
        if 'file2' in params:
            path_params['file2'] = params['file2']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/link/{repository}/{model}/{file1}/{file2}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_note_using_delete(self, model, note, repository, token, **kwargs):  # noqa: E501
        """Delete sticky note from the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_note_using_delete(model, note, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int note: ID of the note (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_note_using_delete_with_http_info(model, note, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_note_using_delete_with_http_info(model, note, repository, token, **kwargs)  # noqa: E501
            return data

    def delete_note_using_delete_with_http_info(self, model, note, repository, token, **kwargs):  # noqa: E501
        """Delete sticky note from the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_note_using_delete_with_http_info(model, note, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param int note: ID of the note (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'note', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_note_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `delete_note_using_delete`")  # noqa: E501
        # verify the required parameter 'note' is set
        if ('note' not in params or
                params['note'] is None):
            raise ValueError("Missing the required parameter `note` when calling `delete_note_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `delete_note_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `delete_note_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'note' in params:
            path_params['note'] = params['note']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/note/{repository}/{model}/{note}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_data_using_get(self, name, src, token, **kwargs):  # noqa: E501
        """Return file data for download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_data_using_get(name, src, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Name for the download file (required)
        :param str src: Source file name on the server for download (required)
        :param str token: Server connection token (required)
        :return: ByteArrayResource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_data_using_get_with_http_info(name, src, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_data_using_get_with_http_info(name, src, token, **kwargs)  # noqa: E501
            return data

    def get_file_data_using_get_with_http_info(self, name, src, token, **kwargs):  # noqa: E501
        """Return file data for download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_data_using_get_with_http_info(name, src, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Name for the download file (required)
        :param str src: Source file name on the server for download (required)
        :param str token: Server connection token (required)
        :return: ByteArrayResource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'src', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_data_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_file_data_using_get`")  # noqa: E501
        # verify the required parameter 'src' is set
        if ('src' not in params or
                params['src'] is None):
            raise ValueError("Missing the required parameter `src` when calling `get_file_data_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_file_data_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'src' in params:
            path_params['src'] = params['src']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/file/data/{src}/{name}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ByteArrayResource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file_ver_link_using_get(self, model, name, repository, token, ver, **kwargs):  # noqa: E501
        """Prepare the file of the document for download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_ver_link_using_get(model, name, repository, token, ver, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str name: Name for the document file (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int ver: Instance ID of the document version (required)
        :return: FileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_ver_link_using_get_with_http_info(model, name, repository, token, ver, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_ver_link_using_get_with_http_info(model, name, repository, token, ver, **kwargs)  # noqa: E501
            return data

    def get_file_ver_link_using_get_with_http_info(self, model, name, repository, token, ver, **kwargs):  # noqa: E501
        """Prepare the file of the document for download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_ver_link_using_get_with_http_info(model, name, repository, token, ver, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str name: Name for the document file (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int ver: Instance ID of the document version (required)
        :return: FileInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'name', 'repository', 'token', 'ver']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file_ver_link_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_file_ver_link_using_get`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_file_ver_link_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_file_ver_link_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_file_ver_link_using_get`")  # noqa: E501
        # verify the required parameter 'ver' is set
        if ('ver' not in params or
                params['ver'] is None):
            raise ValueError("Missing the required parameter `ver` when calling `get_file_ver_link_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'ver' in params:
            query_params.append(('ver', params['ver']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/file/link/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FileInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_users_and_roles_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Return the available users and roles in the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_users_and_roles_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: UsersRolesInfoPackage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_users_and_roles_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_users_and_roles_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def get_project_users_and_roles_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Return the available users and roles in the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_users_and_roles_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: UsersRolesInfoPackage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_users_and_roles_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `get_project_users_and_roles_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `get_project_users_and_roles_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `get_project_users_and_roles_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/info/users/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UsersRolesInfoPackage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def link_file_to_file_using_put(self, file1, file2, model, repository, token, **kwargs):  # noqa: E501
        """Add documents relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.link_file_to_file_using_put(file1, file2, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file1: Instance ID of the affected document's current version (required)
        :param int file2: Instance ID of the affecting document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.link_file_to_file_using_put_with_http_info(file1, file2, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.link_file_to_file_using_put_with_http_info(file1, file2, model, repository, token, **kwargs)  # noqa: E501
            return data

    def link_file_to_file_using_put_with_http_info(self, file1, file2, model, repository, token, **kwargs):  # noqa: E501
        """Add documents relationship  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.link_file_to_file_using_put_with_http_info(file1, file2, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file1: Instance ID of the affected document's current version (required)
        :param int file2: Instance ID of the affecting document's current version (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file1', 'file2', 'model', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method link_file_to_file_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file1' is set
        if ('file1' not in params or
                params['file1'] is None):
            raise ValueError("Missing the required parameter `file1` when calling `link_file_to_file_using_put`")  # noqa: E501
        # verify the required parameter 'file2' is set
        if ('file2' not in params or
                params['file2'] is None):
            raise ValueError("Missing the required parameter `file2` when calling `link_file_to_file_using_put`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `link_file_to_file_using_put`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `link_file_to_file_using_put`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `link_file_to_file_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file1' in params:
            path_params['file1'] = params['file1']  # noqa: E501
        if 'file2' in params:
            path_params['file2'] = params['file2']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/file_link/{repository}/{model}/{file1}/{file2}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def paste_file_using_put(self, file, model, move, node, repository, token, **kwargs):  # noqa: E501
        """Move/Copy document to the specified breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.paste_file_using_put(file, model, move, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param bool move: Use move(true) or copy(false) operation (required)
        :param int node: Instance ID of the breakdown element (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.paste_file_using_put_with_http_info(file, model, move, node, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.paste_file_using_put_with_http_info(file, model, move, node, repository, token, **kwargs)  # noqa: E501
            return data

    def paste_file_using_put_with_http_info(self, file, model, move, node, repository, token, **kwargs):  # noqa: E501
        """Move/Copy document to the specified breakdown element  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.paste_file_using_put_with_http_info(file, model, move, node, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param bool move: Use move(true) or copy(false) operation (required)
        :param int node: Instance ID of the breakdown element (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'model', 'move', 'node', 'repository', 'token', 'act_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method paste_file_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `paste_file_using_put`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `paste_file_using_put`")  # noqa: E501
        # verify the required parameter 'move' is set
        if ('move' not in params or
                params['move'] is None):
            raise ValueError("Missing the required parameter `move` when calling `paste_file_using_put`")  # noqa: E501
        # verify the required parameter 'node' is set
        if ('node' not in params or
                params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `paste_file_using_put`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `paste_file_using_put`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `paste_file_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file' in params:
            path_params['file'] = params['file']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'node' in params:
            path_params['node'] = params['node']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501
        if 'move' in params:
            query_params.append(('move', params['move']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/link/{repository}/{model}/{node}/{file}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataFileInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quick_search_using_get1(self, model, pattern, repository, token, **kwargs):  # noqa: E501
        """Search documents by string pattern  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quick_search_using_get1(model, pattern, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str pattern: Search string pattern (for LIKE operations in EXPRESS) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool case_sens: Use case sensitive search or not
        :param str domains: CSV list of subjects for search, can include ID, DESCRIPTION, CLASS, PROPERY
        :param int node: Breakdown element instance id - root of interesting branch
        :param int page: Start page of output
        :param int page_size: Page size of output
        :param str props: CSV list of property names where to apply search pattern (when PROPERTY is listed)
        :return: list[DataFileSearchResultInfoEx]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quick_search_using_get1_with_http_info(model, pattern, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.quick_search_using_get1_with_http_info(model, pattern, repository, token, **kwargs)  # noqa: E501
            return data

    def quick_search_using_get1_with_http_info(self, model, pattern, repository, token, **kwargs):  # noqa: E501
        """Search documents by string pattern  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quick_search_using_get1_with_http_info(model, pattern, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str pattern: Search string pattern (for LIKE operations in EXPRESS) (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param bool case_sens: Use case sensitive search or not
        :param str domains: CSV list of subjects for search, can include ID, DESCRIPTION, CLASS, PROPERY
        :param int node: Breakdown element instance id - root of interesting branch
        :param int page: Start page of output
        :param int page_size: Page size of output
        :param str props: CSV list of property names where to apply search pattern (when PROPERTY is listed)
        :return: list[DataFileSearchResultInfoEx]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'pattern', 'repository', 'token', 'case_sens', 'domains', 'node', 'page', 'page_size', 'props']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quick_search_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `quick_search_using_get1`")  # noqa: E501
        # verify the required parameter 'pattern' is set
        if ('pattern' not in params or
                params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `quick_search_using_get1`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `quick_search_using_get1`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `quick_search_using_get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'case_sens' in params:
            query_params.append(('case_sens', params['case_sens']))  # noqa: E501
        if 'domains' in params:
            query_params.append(('domains', params['domains']))  # noqa: E501
        if 'node' in params:
            query_params.append(('node', params['node']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'pattern' in params:
            query_params.append(('pattern', params['pattern']))  # noqa: E501
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/q_search/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DataFileSearchResultInfoEx]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_documents_by_content_using_get(self, model, pattern, repository, token, **kwargs):  # noqa: E501
        """Search for the documents by content  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_documents_by_content_using_get(model, pattern, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str pattern: Search pattern for the document content (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int limit: Limit for the number of search result
        :return: list[DataFileSearchResultInfoEx]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_documents_by_content_using_get_with_http_info(model, pattern, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.search_documents_by_content_using_get_with_http_info(model, pattern, repository, token, **kwargs)  # noqa: E501
            return data

    def search_documents_by_content_using_get_with_http_info(self, model, pattern, repository, token, **kwargs):  # noqa: E501
        """Search for the documents by content  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_documents_by_content_using_get_with_http_info(model, pattern, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str pattern: Search pattern for the document content (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int limit: Limit for the number of search result
        :return: list[DataFileSearchResultInfoEx]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'pattern', 'repository', 'token', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_documents_by_content_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `search_documents_by_content_using_get`")  # noqa: E501
        # verify the required parameter 'pattern' is set
        if ('pattern' not in params or
                params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `search_documents_by_content_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `search_documents_by_content_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `search_documents_by_content_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'pattern' in params:
            query_params.append(('pattern', params['pattern']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/txt_search/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DataFileSearchResultInfoEx]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_documents_using_get(self, model, repository, token, **kwargs):  # noqa: E501
        """Search for the documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_documents_using_get(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str descr: Search pattern for the document description
        :param str discipline: Search value for the document discipline
        :param str doc_status: Search value for the document status
        :param str doc_type: Search value for the document type
        :param str editor: Search value for the document editor person
        :param int node_id: Root element's instance ID of the branch to search within
        :param str node_ver: Version number of the element to search within
        :param str p_phase: Search value for the document project phase
        :param str responsible: Search value for the document responsible person
        :param str title: Search pattern for the document title
        :return: list[DataFileSearchResultInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_documents_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.search_documents_using_get_with_http_info(model, repository, token, **kwargs)  # noqa: E501
            return data

    def search_documents_using_get_with_http_info(self, model, repository, token, **kwargs):  # noqa: E501
        """Search for the documents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_documents_using_get_with_http_info(model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str descr: Search pattern for the document description
        :param str discipline: Search value for the document discipline
        :param str doc_status: Search value for the document status
        :param str doc_type: Search value for the document type
        :param str editor: Search value for the document editor person
        :param int node_id: Root element's instance ID of the branch to search within
        :param str node_ver: Version number of the element to search within
        :param str p_phase: Search value for the document project phase
        :param str responsible: Search value for the document responsible person
        :param str title: Search pattern for the document title
        :return: list[DataFileSearchResultInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model', 'repository', 'token', 'descr', 'discipline', 'doc_status', 'doc_type', 'editor', 'node_id', 'node_ver', 'p_phase', 'responsible', 'title']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_documents_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `search_documents_using_get`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `search_documents_using_get`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `search_documents_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'descr' in params:
            query_params.append(('descr', params['descr']))  # noqa: E501
        if 'discipline' in params:
            query_params.append(('discipline', params['discipline']))  # noqa: E501
        if 'doc_status' in params:
            query_params.append(('docStatus', params['doc_status']))  # noqa: E501
        if 'doc_type' in params:
            query_params.append(('docType', params['doc_type']))  # noqa: E501
        if 'editor' in params:
            query_params.append(('editor', params['editor']))  # noqa: E501
        if 'node_id' in params:
            query_params.append(('nodeID', params['node_id']))  # noqa: E501
        if 'node_ver' in params:
            query_params.append(('nodeVer', params['node_ver']))  # noqa: E501
        if 'p_phase' in params:
            query_params.append(('pPhase', params['p_phase']))  # noqa: E501
        if 'responsible' in params:
            query_params.append(('responsible', params['responsible']))  # noqa: E501
        if 'title' in params:
            query_params.append(('title', params['title']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/search/{repository}/{model}/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DataFileSearchResultInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_read_only_doc_using_put(self, doc, model, read_only, repository, token, **kwargs):  # noqa: E501
        """Set or unset read only access for the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_read_only_doc_using_put(doc, model, read_only, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param bool read_only: Set(true) or unset(false) read only access (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_read_only_doc_using_put_with_http_info(doc, model, read_only, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.set_read_only_doc_using_put_with_http_info(doc, model, read_only, repository, token, **kwargs)  # noqa: E501
            return data

    def set_read_only_doc_using_put_with_http_info(self, doc, model, read_only, repository, token, **kwargs):  # noqa: E501
        """Set or unset read only access for the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_read_only_doc_using_put_with_http_info(doc, model, read_only, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param bool read_only: Set(true) or unset(false) read only access (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc', 'model', 'read_only', 'repository', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_read_only_doc_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'doc' is set
        if ('doc' not in params or
                params['doc'] is None):
            raise ValueError("Missing the required parameter `doc` when calling `set_read_only_doc_using_put`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `set_read_only_doc_using_put`")  # noqa: E501
        # verify the required parameter 'read_only' is set
        if ('read_only' not in params or
                params['read_only'] is None):
            raise ValueError("Missing the required parameter `read_only` when calling `set_read_only_doc_using_put`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `set_read_only_doc_using_put`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `set_read_only_doc_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'doc' in params:
            path_params['doc'] = params['doc']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'read_only' in params:
            query_params.append(('read_only', params['read_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/acc/{repository}/{model}/{doc}/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def undo_checkout_file_using_delete(self, file, model, repository, token, **kwargs):  # noqa: E501
        """Cancel the document Check Out operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.undo_checkout_file_using_delete(file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.undo_checkout_file_using_delete_with_http_info(file, model, repository, token, **kwargs)  # noqa: E501
        else:
            (data) = self.undo_checkout_file_using_delete_with_http_info(file, model, repository, token, **kwargs)  # noqa: E501
            return data

    def undo_checkout_file_using_delete_with_http_info(self, file, model, repository, token, **kwargs):  # noqa: E501
        """Cancel the document Check Out operation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.undo_checkout_file_using_delete_with_http_info(file, model, repository, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int file: Instance ID of the document assignment (required)
        :param str model: Model name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param int act_timestamp: Timestamp of the request
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file', 'model', 'repository', 'token', 'act_timestamp']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method undo_checkout_file_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file' is set
        if ('file' not in params or
                params['file'] is None):
            raise ValueError("Missing the required parameter `file` when calling `undo_checkout_file_using_delete`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `undo_checkout_file_using_delete`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `undo_checkout_file_using_delete`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `undo_checkout_file_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file' in params:
            path_params['file'] = params['file']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'act_timestamp' in params:
            query_params.append(('act_timestamp', params['act_timestamp']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/file_checkout/{repository}/{model}/{file}/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataFileInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_class_using_post(self, doc, model, name, repository, token, val, **kwargs):  # noqa: E501
        """Update system properties of the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_class_using_post(doc, model, name, repository, token, val, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param str name: Property name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str val: Property value (required)
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_class_using_post_with_http_info(doc, model, name, repository, token, val, **kwargs)  # noqa: E501
        else:
            (data) = self.update_class_using_post_with_http_info(doc, model, name, repository, token, val, **kwargs)  # noqa: E501
            return data

    def update_class_using_post_with_http_info(self, doc, model, name, repository, token, val, **kwargs):  # noqa: E501
        """Update system properties of the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_class_using_post_with_http_info(doc, model, name, repository, token, val, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param str name: Property name (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param str val: Property value (required)
        :return: DataFileInfoWrapper
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc', 'model', 'name', 'repository', 'token', 'val']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_class_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'doc' is set
        if ('doc' not in params or
                params['doc'] is None):
            raise ValueError("Missing the required parameter `doc` when calling `update_class_using_post`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `update_class_using_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_class_using_post`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `update_class_using_post`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_class_using_post`")  # noqa: E501
        # verify the required parameter 'val' is set
        if ('val' not in params or
                params['val'] is None):
            raise ValueError("Missing the required parameter `val` when calling `update_class_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'doc' in params:
            path_params['doc'] = params['doc']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'val' in params:
            query_params.append(('val', params['val']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/class/{repository}/{model}/{doc}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataFileInfoWrapper',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_prop_using_post1(self, doc, model, props, ptypes, repository, token, vals, **kwargs):  # noqa: E501
        """Update user defined properties of the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prop_using_post1(doc, model, props, ptypes, repository, token, vals, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param list[str] props: Property names (required)
        :param list[str] ptypes: Property types. T - text, N - numeric, D - data, B - boolean (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] vals: Property values (required)
        :param list[str] units: Property unites
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_prop_using_post1_with_http_info(doc, model, props, ptypes, repository, token, vals, **kwargs)  # noqa: E501
        else:
            (data) = self.update_prop_using_post1_with_http_info(doc, model, props, ptypes, repository, token, vals, **kwargs)  # noqa: E501
            return data

    def update_prop_using_post1_with_http_info(self, doc, model, props, ptypes, repository, token, vals, **kwargs):  # noqa: E501
        """Update user defined properties of the document  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_prop_using_post1_with_http_info(doc, model, props, ptypes, repository, token, vals, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int doc: Instance ID of the document's current version (required)
        :param str model: Model name (required)
        :param list[str] props: Property names (required)
        :param list[str] ptypes: Property types. T - text, N - numeric, D - data, B - boolean (required)
        :param str repository: Repository name (required)
        :param str token: Server connection token (required)
        :param list[str] vals: Property values (required)
        :param list[str] units: Property unites
        :return: StatusOfAction
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['doc', 'model', 'props', 'ptypes', 'repository', 'token', 'vals', 'units']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_prop_using_post1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'doc' is set
        if ('doc' not in params or
                params['doc'] is None):
            raise ValueError("Missing the required parameter `doc` when calling `update_prop_using_post1`")  # noqa: E501
        # verify the required parameter 'model' is set
        if ('model' not in params or
                params['model'] is None):
            raise ValueError("Missing the required parameter `model` when calling `update_prop_using_post1`")  # noqa: E501
        # verify the required parameter 'props' is set
        if ('props' not in params or
                params['props'] is None):
            raise ValueError("Missing the required parameter `props` when calling `update_prop_using_post1`")  # noqa: E501
        # verify the required parameter 'ptypes' is set
        if ('ptypes' not in params or
                params['ptypes'] is None):
            raise ValueError("Missing the required parameter `ptypes` when calling `update_prop_using_post1`")  # noqa: E501
        # verify the required parameter 'repository' is set
        if ('repository' not in params or
                params['repository'] is None):
            raise ValueError("Missing the required parameter `repository` when calling `update_prop_using_post1`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `update_prop_using_post1`")  # noqa: E501
        # verify the required parameter 'vals' is set
        if ('vals' not in params or
                params['vals'] is None):
            raise ValueError("Missing the required parameter `vals` when calling `update_prop_using_post1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'doc' in params:
            path_params['doc'] = params['doc']  # noqa: E501
        if 'model' in params:
            path_params['model'] = params['model']  # noqa: E501
        if 'repository' in params:
            path_params['repository'] = params['repository']  # noqa: E501
        if 'token' in params:
            path_params['token'] = params['token']  # noqa: E501

        query_params = []
        if 'props' in params:
            query_params.append(('props', params['props']))  # noqa: E501
            collection_formats['props'] = 'multi'  # noqa: E501
        if 'ptypes' in params:
            query_params.append(('ptypes', params['ptypes']))  # noqa: E501
            collection_formats['ptypes'] = 'multi'  # noqa: E501
        if 'units' in params:
            query_params.append(('units', params['units']))  # noqa: E501
            collection_formats['units'] = 'multi'  # noqa: E501
        if 'vals' in params:
            query_params.append(('vals', params['vals']))  # noqa: E501
            collection_formats['vals'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/dat/prop/{repository}/{model}/{doc}/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatusOfAction',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
